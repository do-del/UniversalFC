C51 COMPILER V9.60.0.0   MAIN                                                              01/13/2023 16:45:52 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_c51\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\mai
                    -n.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "stc8h.h"
   2          #include <intrins.h>
   3          
   4          /*
   5           * PWM1P1.0PWMƵUλMOSѡͨźţߵƽͨ͵ƽֹ
   6           * PWM1_LP1.1ƵUλMOSѡͨźţߵƽͨ͵ƽֹ
   7           * PWM2P1.2PWMƵVλMOSѡͨźţߵƽͨ͵ƽֹ
   8           * PWM2_LP1.3ƵVλMOSѡͨźţߵƽͨ͵ƽֹ
   9           * PWM3P1.4PWMƵWλMOSѡͨźţߵƽͨ͵ƽֹ
  10           * PWM3_LP1.5ƵWλMOSѡͨźţߵƽͨ͵ƽֹ
  11           * ADC8P0.0ø룬UӦ綯ƣڹȽ
  12           * ADC9P0.1ø룬VӦ綯
  13           * ADC10P0.2ø룬WӦ綯
  14           * CMP-P3.6Ϊ룬ӹ·е
  15          */
  16          
  17          /*
  18           * ˢͨ
  19           * AB-AC-BC-BA-CA-CB-AB
  20           * ӦӦ綯Ʊ仯
  21           * C½-B-A½-C-B½-A-C½
  22          */
  23          
  24          #define FOSC 24000000UL //ϵͳʱ
  25          #define BRT (65536-(FOSC/115200+2)/4) //תֵ
  26          
  27          typedef unsigned char u8;
  28          typedef unsigned int u16;
  29          typedef unsigned long u32;
  30          
  31          #define PWM1    P10
  32          #define PWM1_L  P11
  33          #define PWM2    P12
  34          #define PWM2_L  P13
  35          #define PWM3    P14
  36          #define PWM3_L  P15
  37          
  38          #define ADC_START (1<<6)  //ADӿƼĴbit6ADCתλд1ʼADCת
  39          #define ADC_FLAG (1<<5) //ADCƼĴbit5ADCת־λ
  40          #define ADC_SPEED 1     //ADCüĴbit3~bit0ADCʱƵ
  41          #define RES_FMT (1<<5)  //ADCüĴbit51ADCҶ룬0ADC
  42          #define CSSETUP (0<<7)  //ADCTIMʱƼĴͨѡʱλbit7ռһʱ
  43          #define CSHOLD (1<<5)   //ADCTIMʱƼĴͨʱλbit6~bit5ռ2ʱ
  44          #define SMPDUTY 20      //ADCTIMʱƼĴͨʱλbit4~bit0ռ21ʱС10
  45          
  46          #define RX_LEN 16 //ڽݻ泤
  47          bit busy;   //ڷɱ־
  48          char wptr;  //ڽݳ
  49          char buffer[RX_LEN]; //ڽݻ
  50          
  51          void Port_Init(void); //оƬλųʼ
  52          void PWMA_Config(void); //PWMAú
  53          void ADC_Config(void);  //ADCú
  54          void CMP_Config(void);  //Ƚú
C51 COMPILER V9.60.0.0   MAIN                                                              01/13/2023 16:45:52 PAGE 2   

  55          void Timer0_Config(void); //ʱ0úѿʱ0жϣ4msһΣ
  56          void Timer3_Config(void); //ʱ3ú
  57          void Timer4_Config(void); //ʱ4ú
  58          
  59          #define delay_200ns() do{_nop_();_nop_();_nop_();_nop_();}while(0) //MOSֲʱ䣬ֲõMO
             -SܵͨضʱΪ55ns˴Ϊ200nsʱ
  60          #define delay_dead() delay_200ns()
  61          u16 Get_ADCRes(u8 ch);  //ȡADCָͨ
  62          void Motor_Start(void); //
  63          void Motor_Step(void); //ຯ
  64          
  65          //ú
  66          void Uart_Config(void); //ڳʼ
  67          void UartSend(char dat); //ڷֽ
  68          void UartSendStr(char *p); //ڷַ
  69          void UartSendNum(int num); //ڷ-32767~32768Χڵ
  70          
  71          u8 step; //ͨţ࣬Χ0~5
  72          bit m_starting; //־
  73          bit m_running;  //б־
  74          u8 demagnetizing_cnt; //żֵ1ΪҪţ2Ϊţ0ΪѾţʼΪ0кȽж
             -¼1ڼûʱ䣩ڶʱ4жϻ
  75          bit t3_flag; //Timer3־32.768ms1һ
  76          bit t0_flag; //Timer0־4ms1һ
  77          #define TMP_LEN 8
  78          u8 time_index;
  79          u16 phase_time_tmp[TMP_LEN];
  80          
  81          void UartIsr() interrupt 4
  82          {
  83   1        if(TI)
  84   1        {
  85   2          TI = 0;
  86   2          busy = 0;
  87   2        }
  88   1        if(RI)
  89   1        {
  90   2          RI = 0;
  91   2          buffer[wptr++] = SBUF;
  92   2          if(SBUF == '\n')
  93   2            wptr |= 0x80;
  94   2        }
  95   1      }
  96          
  97          void UartRxTest(void)
  98          {
  99   1        if(wptr & 0x80)
 100   1        {
 101   2          unsigned char len = wptr & 0x7f;
 102   2          u8 i;
 103   2          UartSendStr(buffer);
 104   2          for(i = 0;i<len;i++)
 105   2            buffer[i] = 0;
 106   2          wptr = 0;
 107   2        }
 108   1      }
 109          
 110          void main(void)
 111          {
 112   1        P_SW2 |= 0x80; //ʹXFR
 113   1        
 114   1        Port_Init();  //ö˿ڳʼ
C51 COMPILER V9.60.0.0   MAIN                                                              01/13/2023 16:45:52 PAGE 3   

 115   1        PWMA_Config();  //PWMAʼ
 116   1        ADC_Config(); //ADCʼ
 117   1        CMP_Config(); //ģȽʼ
 118   1        Timer0_Config();  //öʱ0ʼ
 119   1        Timer3_Config();  //öʱ3ʼ
 120   1        Timer4_Config();  //öʱ4ʼ
 121   1        
 122   1        Uart_Config();  //ôڳʼ
 123   1        ES = 1;
 124   1        EA = 1; //ж
 125   1        
 126   1        UartSendStr("--Brushless ESC Test--\r\n");
 127   1        
 128   1        //PWMA_ENO = 0x15; //0x15 = 0b0001 0101PWMAܣʹPWM1PPWM2PPWM3P
 129   1        
 130   1        while(1)
 131   1        {
 132   2          u16 res;
 133   2          UartRxTest(); //Uartշ
 134   2          
 135   2          //ADC
 136   2          res = Get_ADCRes(8);
 137   2          UartSendStr("ADC8:");
 138   2          UartSendNum(res);
 139   2          UartSendStr("\r\n");
 140   2        }
 141   1      }
 142          
 143          void Port_Init(void)
 144          {
 145   1        P0M0 = 0x00;
 146   1        P0M1 = 0x00; //P0˿ڳʼΪ˫
 147   1        P1M0 = 0x00;
 148   1        P1M1 = 0x00; //P1˿ڳʼΪ˫
 149   1        P2M0 = 0x00;
 150   1        P2M1 = 0x00; //P2˿ڳʼΪ˫
 151   1        P3M0 = 0x00;
 152   1        P3M1 = 0x00; //P3˿ڳʼΪ˫
 153   1        P5M0 = 0x00;
 154   1        P5M0 = 0x00; //P5˿ڳʼΪ˫
 155   1      }
 156          
 157          void PWMA_Config(void)
 158          {
 159   1        //ȽMOSѡͨźֹͣͨ
 160   1        PWM1 = 0;
 161   1        PWM1_L = 0;
 162   1        PWM2 = 0;
 163   1        PWM2_L = 0;
 164   1        PWM3 = 0;
 165   1        PWM3_L = 0;
 166   1        
 167   1        //ѡͨΪM0ӦbitΪ1M1ӦbitΪ0
 168   1        P1M0 |= 0x3f; //0x3f = 0B0011 1111bit0~bit51
 169   1        P1M1 &= ~0x3f; //~0x3f = 0B1100 0000,bit0~bit50
 170   1        
 171   1        PWMA_PSCR = 3;  //PWMA_PSCRΪPWMA16λԤƵĴ16λݶдf_ck_int = f_ck_psc/(PSCR[15:0]+1
             -)
 172   1        PWMA_DTR = 24;  //PWMA_DTRλPWMAĴʱ䣬δ
 173   1        
 174   1        PWMA_ARR = 255; //PWMA_ARRΪPWMA16λԶؼĴ
 175   1        PWMA_CCER1 = 0; ///ȽʹܼĴ1üԼʹ
C51 COMPILER V9.60.0.0   MAIN                                                              01/13/2023 16:45:52 PAGE 4   

 176   1        PWMA_CCER2 = 0; ///ȽʹܼĴ2üԼʹ
 177   1        PWMA_SR1 = 0;   //״̬Ĵ1жϱ
 178   1        PWMA_SR2 = 0;   //״̬Ĵ2ظ
 179   1        PWMA_ENO = 0;   //ʹܼĴ
 180   1        PWMA_PS = 0;    //ܽл
 181   1        PWMA_IER = 0;   //жʹܼĴ
 182   1        
 183   1        PWMA_CCMR1 = 0x68;  ///ȽģʽĴ10x68 = 0b0110 1000ΪԤװأPWMģʽ1
 184   1        PWMA_CCR1 = 127;      ///ȽϼĴ16λǰȽֵ
 185   1        PWMA_CCER1 |= 0x01; ///ȽʹܼĴ1ԭ0x05 = 0b0000 0101,ָΪ0x01ʹOC1
 186   1        PWMA_PS |= 0;       //PWMA IOѡ
 187   1        
 188   1        PWMA_CCMR2 = 0x68;  ///ȽģʽĴ20x68 = 0b0110 1000ΪԤװأPWMģʽ1
 189   1        PWMA_CCR2 = 63;     ///ȽϼĴ16λǰȽֵPWMA_ARRȽ
 190   1        PWMA_CCER1 |= 0x10; ///ȽʹܼĴ1ԭ0x50 = 0b0101 0000ָΪ0x10ʹOC2
 191   1        PWMA_PS |= (0<<2);  //PWMA IOѡ
 192   1        
 193   1        PWMA_CCMR3 = 0x68;  ///ȽģʽĴ30x68 = 0b0110 1000ΪԤװأPWMģʽ1
 194   1        PWMA_CCR3 = 191;      ///ȽϼĴ16λǰȽֵ
 195   1        PWMA_CCER2 |= 0x01; ///ȽʹܼĴ2ԭ0x05 = 0b0000 0101,ָΪ0x01ʹOC3
 196   1        PWMA_PS |= (0<<4);  //PWMA IOѡ
 197   1        
 198   1        PWMA_BKR = 0x80;  //ʹOCOCN
 199   1        PWMA_CR1 = 0x81;  //ƼĴ1ʹԶԤװأض룬ϼʹܼ
 200   1        PWMA_EGR = 0x01;  //ʼ
 201   1      }
 202          
 203          void ADC_Config(void)
 204          {
 205   1        //ģʽΪ룬M1ӦbitΪ1M0ӦbitΪ0
 206   1        P1M1 |= 0xc0; //־λ1
 207   1        P1M0 &= ~0xc0; //־λ0
 208   1        
 209   1        //ģʽΪ룬M1ӦbitΪ1M0ӦbitΪ0
 210   1        P0M1 |= 0x0f;  //־λ1
 211   1        P0M0 &= ~0x0f; //־λ0
 212   1        
 213   1        ADC_CONTR = 0x80+6; //ADCƼĴbit71ADCԴbit3~bit0ΪͨѡλSTC8H1K28ϵADC12~ADC1
             -4.STC8H1K08ϵADC2~ADC7
 214   1        ADCCFG = RES_FMT + ADC_SPEED; //ADCüĴbit5ʽƣ0룬1Ҷ룬bit3~bit0ADCʱ
             -Ƶʣf=Sysclk/2/(speed+1)
 215   1        ADCTIM = CSSETUP + CSHOLD + SMPDUTY;  //ADCʱƼĴbit7T_setup | bit6~bit5T_hold | bit4~bit0
             -T_duty
 216   1      }
 217          
 218          void CMP_Config(void)
 219          {
 220   1        //CMP-Ϊ룬M1ӦbitΪ1M0ӦbitΪ0
 221   1        P3M1 |= 0x40; //0x40 = 0b0100 0000,bit61
 222   1        P3M0 &= ~0x40; //~0x40 = 0b1011 1111bit60
 223   1        
 224   1        CMPCR1 = 0x8C;  //ȽƼĴ1bit7ģʹܣbit6жϱ־λbit5жʹܣbit4½жʹ
 225   1                        //bit3ѡbit2ѡbit1ƣbit0ȽϽ
 226   1                        //0x80 = 0b1000 1100ʹܱȽADCΪ룬P3.6Ϊ
 227   1        CMPCR2 = 60; //ȽƼĴ2bit7ƣbit6ģ˲ƣ0ʹܣbit5~bit0˲ʱ
 228   1      }
 229          
 230          void Timer0_Config(void)
 231          {
 232   1        TMOD &= ~0x03;    //ʱ0/1ģʽĴ~0x03 = 0b1111 1100bit1~bit0㣬ʱ0Ϊ16λԶģʽ
 233   1        AUXR &= ~(1<<7);  //Ĵ1bit70ʱ0ʱΪCPUʱ12Ƶ24MHz/12 = 2MHz
 234   1        
C51 COMPILER V9.60.0.0   MAIN                                                              01/13/2023 16:45:52 PAGE 5   

 235   1        //12Ƶ£ʱ=(65536-[TH0,TL0])*12/FOSC,4msʱ= 0.004 = 1/250
 236   1        TH0 = (65536UL - FOSC / 12 / 250)>>8; //ʱ0Ĵ
 237   1        TL0 = (u8)(65536UL - FOSC / 12 / 250); //ʱ0Ĵ
 238   1        TR0 = 1;  //ʱ0
 239   1        ET0 = 1;  //ʹܶʱ0ж
 240   1      }
 241          
 242          void Timer3_Config(void)
 243          {
 244   1        T4T3M &= 0xf0;  //ʱ3/4ƼĴ4λʱ44λʱ34λ㣬ʱ3ֹͣʱ
             -12Ƶرʱ
 245   1        T3H = 0;  //ʱ3Ĵ
 246   1        T3L = 0;  //ʱ3Ĵ
 247   1        
 248   1        T3T4PIN = 0x01; //ʱ3/4лĴbit0ѡλ1ѡP0.0P0.1P0.2P0.3
 249   1        IE2 |= (1<<5);  //жʹܼĴ2bit5Ϊʱ3жλ1ж
 250   1        T4T3M |= (1<<3);  //ʱ3/4ƼĴbit31ʱ3ʼ
 251   1      }
 252          
 253          void Timer4_Config(void)
 254          {
 255   1        T4T3M &= 0x0f; //ʱ3/4ƼĴ4λʱ44λʱ34λ㣬ʱ4ֹͣʱ
             -12Ƶرʱ
 256   1        T4H = 0;  //ʱ4Ĵ
 257   1        T4L = 0;  //ʱ4Ĵ
 258   1        
 259   1        //T4H = (u8)((65536UL - 40*2) >> 8);  //ãʱ4ƵΪ2MHz40usҪ80
 260   1        //T4L = (u8)(65536UL - 40*2); //
 261   1        
 262   1        T3T4PIN = 0x01; //ʱ3/4лĴbit0ѡλ1ѡP0.0P0.1P0.2P0.3
 263   1        IE2 |= (1<<6);  //жʹܼĴ2bit6Ϊʱ4жλ1ж
 264   1        //T4T3M |=  (1<<7); //ʼ
 265   1      }
 266          
 267          u16 Get_ADCRes(u8 ch)
 268          {
 269   1        u8 i = 255; //ADCתʱģʱ
 270   1        ADC_RES = 0;  //ADCתĴ
 271   1        ADC_RESL = 0; //ADCתĴL
 272   1        ADC_CONTR = 0x80|ADC_START|ch; //ѡADCͨʼת
 273   1        _nop_();
 274   1        while(i != 0)
 275   1        {
 276   2          i--;
 277   2          if((ADC_CONTR & ADC_FLAG) != 0) break;  //ȴADC
 278   2        }
 279   1        ADC_CONTR &= ~ADC_FLAG; //תɱ־λ
 280   1        return  ((u16)ADC_RES>>8 + (u16)ADC_RESL); //ضȡ
 281   1      }
 282          
 283          void Motor_Start(void)
 284          {
 285   1        
 286   1      }
 287          
 288          //ຯ
 289          //ݵͨţͨ
 290          void Motor_Step(void)
 291          {
 292   1        switch(step)
 293   1        {
 294   2          case 0: //ABͨ磬ڼCӦ綯ɸ仯AϹܵͨB¹ܵͨMOSܹض
C51 COMPILER V9.60.0.0   MAIN                                                              01/13/2023 16:45:52 PAGE 6   

 295   2            PWMA_ENO = 0x00; //رPWMرһCϹܵͨȹضϣȻAϹ
 296   2            PWM1_L = 0; //A¹ܹض
 297   2            PWM3_L = 0; //C¹ܹض
 298   2            delay_dead(); //ӳ٣ֹACϹͬʱͨ
 299   2            PWMA_ENO = 0x01; //AϹPWM
 300   2            PWM2_L = 1; //B¹ܵͨ
 301   2            ADC_CONTR = 0x80+10; //ѡADC10P0.2
 302   2            if(m_running) CMPCR1 = 0x8c + 0x10; //Ƚ½жʹ
 303   2            else CMPCR1 = 0x8c; //ʱرձȽж
 304   2            break;
 305   2          case 1: //ACͨ磬ڼBӦ綯仯AϹܵͨC¹ܵͨMOSܹض
 306   2            PWMA_ENO = 0x01;  //AϹܵͨ
 307   2            PWM1_L = 0; //A¹ܹض
 308   2            PWM2_L = 0; //B¹ܹض
 309   2            delay_dead(); //ӳ٣ֹBC¹ͬʱͨ
 310   2            PWM3_L = 1; //C¹ܵͨ
 311   2            ADC_CONTR = 0x80 + 9; //ѡADC9P0.1
 312   2            if(m_running) CMPCR1 = 0x8c + 0x20; //Ƚжʹ
 313   2            else CMPCR1 = 0x8c; //ʱرձȽж
 314   2            break;
 315   2          case 2: //BCͨ磬ڼAӦ綯ɸ仯BϹܵͨC¹ܵͨMOSܹض
 316   2            PWMA_ENO = 0x00; //رPWMرһAϹܵͨȹضϣȻܿBϹ
 317   2            PWM1_L = 0; //A¹ܹض
 318   2            PWM2_L = 0; //B¹ܹض
 319   2            delay_dead();
 320   2            PWMA_ENO = 0x04;  //BϹPWM
 321   2            PWM3_L = 1; //C¹ܵͨ
 322   2            ADC_CONTR = 0x80+8;   //ѡADC8P0.0
 323   2            if(m_running) CMPCR1 = 0x8c + 0x10; //Ƚ½жʹ
 324   2            else CMPCR1 = 0x8c; //ʱرձȽж
 325   2            break;
 326   2          case 3: //BAͨ磬ڼCӦ綯仯BϹܵͨA¹ܵͨMOSܹض
 327   2            PWMA_ENO = 0x04;  //BϹܣرACϹ
 328   2            PWM2_L = 0; //B¹ܹض
 329   2            PWM3_L = 0; //C¹ܹض
 330   2            delay_dead(); //ʱAC¹
 331   2            PWM1_L = 1; //A¹ܵͨ
 332   2            ADC_CONTR = 0x80 + 10;  //ѡADC10P0.2
 333   2            if(m_running) CMPCR1 = 0x8c + 0x20; //Ƚжʹ
 334   2            else CMPCR1 = 0x8c; //ʱرձȽж
 335   2            break;
 336   2          case 4: //CAͨ磬ڼBӦ綯ɸ仯CϹܵͨA¹ܵͨMOSܹض
 337   2            PWMA_ENO = 0x00;  //رϹPWMֹBCϹͬʱͨ
 338   2            PWM2_L = 0; //B¹ܹض
 339   2            PWM3_L = 0; //C¹ܹض
 340   2            delay_dead(); //ʱBCϹ
 341   2            PWMA_ENO = 0x10;  //ʹCϹPWM
 342   2            PWM1_L = 1; //A¹ܵͨ
 343   2            ADC_CONTR = 0x80+9; //ADC9P0.1
 344   2            if(m_running) CMPCR1 = 0x8c + 0x10; //Ƚ½жʹ
 345   2            else CMPCR1 = 0x8c; //ʱرձȽж
 346   2            break;
 347   2          case 5: //CBͨ磬ڼAӦ綯仯CϹܵͨB¹ܵͨMOSܹض
 348   2            PWMA_ENO = 0x10;  //ʹCϹPWM
 349   2            PWM1_L = 0; //A¹ܹض
 350   2            PWM3_L = 0; //C¹ܹض
 351   2            delay_dead(); //ʱAB¹
 352   2            PWM2_L = 1; //B¹ܵͨ
 353   2            ADC_CONTR = 0x80 + 8; //ADC8P0.0
 354   2            if(m_running) CMPCR1 = 0x8c + 0x20; //Ƚжʹ
 355   2            else CMPCR1 = 0x8c; //ʱرձȽж
 356   2            break;
C51 COMPILER V9.60.0.0   MAIN                                                              01/13/2023 16:45:52 PAGE 7   

 357   2          default:
 358   2            break;
 359   2        }
 360   1      }
 361          
 362          void Uart_Config(void)
 363          {
 364   1        SCON = 0x50;
 365   1        T2L = BRT;
 366   1        T2H = BRT>>8;
 367   1        AUXR = 0x15;
 368   1        wptr = 0;
 369   1        busy = 0;
 370   1      }
 371          
 372          void UartSend(char dat)
 373          {
 374   1        while(busy);
 375   1        busy = 1;
 376   1        SBUF = dat;
 377   1      }
 378          
 379          void UartSendStr(char *p)
 380          {
 381   1        while(*p)
 382   1        {
 383   2          UartSend(*p++);
 384   2        }
 385   1      }
 386          
 387          void UartSendNum(int num)
 388          {
 389   1        char buf[8];
 390   1        u8 dat;
 391   1        u8 i = 0;
 392   1        if(num<0)
 393   1        {
 394   2          UartSend('-');
 395   2          num = -num;
 396   2        }
 397   1        while(num)
 398   1        {
 399   2          dat = num%10;
 400   2          buf[i] = dat + 0x30;
 401   2          num /= 10;
 402   2          i++;
 403   2        }
 404   1        UartSendStr(buf);
 405   1      }
 406          
 407          //ȽжϺ
 408          //⵽¼󣬸ݶʱ3ļֵһι¼ʱ
 409          //8λʱ16ÿλʱ䣬Ϊ´λʱ
 410          void CMP_ISR(void) interrupt 21
 411          {
 412   1        u16 phase_time;
 413   1        u8 i;
 414   1        
 415   1        CMPCR1 %= ~0x40; //жϱ־λ
 416   1        
 417   1        if(demagnetizing_cnt == 0) //ź¼δŲȽж
 418   1        {
C51 COMPILER V9.60.0.0   MAIN                                                              01/13/2023 16:45:52 PAGE 8   

 419   2          T4T3M &= ~(1<<3); //Timer3ֹͣ
 420   2          if(t3_flag)
 421   2          {
 422   3            t3_flag = 0;
 423   3            phase_time = 0x1fff;
 424   3          }
 425   2          else
 426   2          {
 427   3            phase_time = (((u16)T3H<<8)+(u16)T3L)>>1;
 428   3            phase_time &= 0x1ffff;
 429   3          }
 430   2          T3H = 0;
 431   2          T3L = 0;
 432   2          T4T3M |= (1<<3);
 433   2          
 434   2          phase_time_tmp[time_index] = phase_time;
 435   2        }
 436   1      }
*** WARNING C280 IN LINE 413 OF main.c: 'i': unreferenced local variable
 437          
 438          void Timer0_ISR(void) interrupt 1
 439          {
 440   1        //PWM1 = !PWM1; //ʱ0жϲԣתPWM1ŵƽ
 441   1        t0_flag = 1;
 442   1      }
 443          
 444          void Timer3_ISR(void) interrupt 19
 445          {
 446   1        //PWM2 = !PWM2; //ʱ3зֶβԣתPWM2ŵƽ
 447   1        t3_flag = 1;
 448   1      }
 449          
 450          //öʱ4ţԭ򻯳ɶʱ˴Ϊ40usʱԽʱԽ
 451          //󣬶ϵһ࣬ȦĴڻԸе綯ƣţȽڷǸӦ綯ƹʱ
             -
 452          //˴޸demagnetzing_cntżֵıȽж
 453          void Timer4_ISR(void) interrupt 20
 454          {
 455   1        T4T3M &= ~(1<<7); //ʱ3/4ƼĴbit70ʱ4ֹͣ
 456   1        
 457   1        if(demagnetizing_cnt == 1)  //жżֵΪ1ΪҪ
 458   1        {
 459   2          demagnetizing_cnt = 2;  //żֵΪ2Ȼ࣬ٽ
 460   2          if(m_running)
 461   2          {
 462   3            if(++step >= 6) step = 0;
 463   3            Motor_Step();
 464   3          }
 465   2          
 466   2          T4H = 0xff; //40us(65536 - t *2)tλus8λT4H8λT4L
 467   2          T4L = 0xB0; //40us
 468   2          T4T3M |=  (1<<7); //Timer4ʼ
 469   2        }
 470   1        else if(demagnetizing_cnt == 2)
 471   1        {
 472   2          demagnetizing_cnt = 0;
 473   2        }
 474   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1037    ----
C51 COMPILER V9.60.0.0   MAIN                                                              01/13/2023 16:45:52 PAGE 9   

   CONSTANT SIZE    =     34    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     36      18
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
