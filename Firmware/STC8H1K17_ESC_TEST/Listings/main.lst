C51 COMPILER V9.60.0.0   MAIN                                                              01/15/2023 19:33:59 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil51\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main.
                    -lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "stc8h.h"
   2          #include <intrins.h>
   3          
   4          /*
   5           * PWM1接P1.0，配置推挽输出和PWM输出，控制电机U相高位MOS管选通信号，高电平导通，低电平截止
   6           * PWM1_L接P1.1，配置推挽输出，控制电机U相低位MOS管选通信号，高电平导通，低电平截止
   7           * PWM2接P1.2，配置推挽输出和PWM输出，控制电机V相高位MOS管选通信号，高电平导通，低电平截止
   8           * PWM2_L接P1.3，配置推挽输出，控制电机V相低位MOS管选通信号，高电平导通，低电平截止
   9           * PWM3接P1.4，配置推挽输出和PWM输出，控制电机W相高位MOS管选通信号，高电平导通，低电平截止
  10           * PWM3_L接P1.5，配置推挽输出，控制电机W相低位MOS管选通信号，高电平导通，低电平截止
  11           * ADC8（P0.0），配置高阻输入，采样电机U相感应电动势，用于过零检测比较器正输入
  12           * ADC9（P0.1），配置高阻输入，采样电机V相感应电动势
  13           * ADC10（P0.2），配置高阻输入，采样电机W相感应电动势
  14           * CMP-（P3.6），配置为高阻输入，接过零检测电路中点
  15          */
  16          
  17          /*
  18           * 无刷电机通电次序
  19           * AB-AC-BC-BA-CA-CB-AB
  20           * 相对应感应电动势变化
  21           * C下降-B上升-A下降-C上升-B下降-A上升-C下降
  22          */
  23          
  24          #include "sys.h"
  25          #include "common.h"
  26          #include "uart.h"
  27          #include "pwm.h"
  28          #include "adc.h"
  29          #include "motor.h"
  30          #include "timer.h"
  31          #include "cmp.h"
  32          
  33          u16 cap_res_g[16];
  34          u16 cap_res_lp;
  35          
  36          void Port_Init(void); //芯片复位后引脚初始化
  37          
  38          void main(void)
  39          {
  40   1        u8  i;
  41   1        u8 j;
  42   1        u32 sum;
  43   1        
  44   1        P_SW2 |= 0x80; //使能XFR
  45   1        
  46   1        Port_Init();  //调用端口初始化函数
  47   1        
  48   1        PWMA_Config();  //调用PWMA初始化函数
  49   1        ADC_Config(); //调用ADC初始化函数
  50   1        CMP_Config(); //调用模拟比较器初始化函数
  51   1        Timer0_Config();  //调用定时器0初始化函数
  52   1        Timer3_Config();  //调用定时器3初始化函数
  53   1        Timer4_Config();  //调用定时器4初始化函数
  54   1      
C51 COMPILER V9.60.0.0   MAIN                                                              01/15/2023 19:33:59 PAGE 2   

  55   1        PWMB_Config();
  56   1        
  57   1        Uart_Config();  //调用串口初始化函数
  58   1        ES = 1;
  59   1        
  60   1        PWM_Set = 0;
  61   1        PWM_Value = 0;
  62   1        timeout = 0;
  63   1        
  64   1        Delay_n_ms(250);
  65   1        Delay_n_ms(250);
  66   1        EA = 1; //打开总中断
  67   1        
  68   1        UartSendStr("--Brushless ESC Test--\r\n");
  69   1        
  70   1        //PWMA_ENO = 0x15; //0x15 = 0b0001 0101，测试PWMA功能，使能PWM1P，PWM2P，PWM3P输出
  71   1        
  72   1        while(1)
  73   1        {
  74   2          if(t0_flag)
  75   2          {
  76   3            t0_flag = 0;
  77   3            
  78   3            if(timeout != 0)
  79   3            {
  80   4              if(--timeout == 0)
  81   4              {
  82   5                m_running = 0;
  83   5                PWM_Value = 0;
  84   5                CMPCR1 = 0x8c;
  85   5                PWMA_ENO = 0;
  86   5                PWMA_CCR1 = 0;
  87   5                PWMA_CCR2 = 0;
  88   5                PWMA_CCR3 = 0;
  89   5                PWM1_L = 0;
  90   5                PWM2_L = 0;
  91   5                PWM3_L = 0;
  92   5                Delay_n_ms(250);
  93   5              }
  94   4            }
  95   3            if(!m_running && (PWM_Set >= D_START_PWM))
  96   3            {
  97   4              //UartSendStr("-start-\r\n");
  98   4              m_starting = 1;
  99   4              for(i = 0;i<8;i++) phase_time_tmp[i] = 400; 
 100   4              Motor_Start();
 101   4              m_starting = 0;
 102   4              demagnetizing_cnt = 0;
 103   4              CMPCR1 &= ~0x40;
 104   4              if(step & 1)  CMPCR1 = 0xAC;    //上升沿中断
 105   4              else      CMPCR1 = 0x9C;    //下降沿中断
 106   4              m_running = 1;
 107   4              Delay_n_ms(250);  //延时一下, 先启动起来
 108   4              Delay_n_ms(250);
 109   4              timeout = 125;    //启动超时时间 125*4 = 500ms
 110   4            }
 111   3            if(m_running)
 112   3            {
 113   4              //UartSendStr("-run-\r\n");
 114   4              if(PWM_Value < PWM_Set) PWM_Value++;
 115   4              if(PWM_Value > PWM_Set) PWM_Value--;
 116   4              if(PWM_Value<(D_START_PWM-5))
C51 COMPILER V9.60.0.0   MAIN                                                              01/15/2023 19:33:59 PAGE 3   

 117   4              {
 118   5                m_running = 0;
 119   5                PWM_Value = 0;
 120   5                CMPCR1 = 0x8c;
 121   5                PWMA_ENO = 0;
 122   5                PWM1_L = 0;
 123   5                PWM2_L = 0;
 124   5                PWM3_L = 0;
 125   5              }
 126   4              PWMA_CCR1L = PWM_Value;
 127   4              PWMA_CCR2L = PWM_Value;
 128   4              PWMA_CCR3L = PWM_Value;
 129   4            }
 130   3            
 131   3            cap_res_g[j] = pwmb_cap_res;
 132   3            j++;
 133   3            j &= 0x0f;
 134   3            for(sum = 0,i = 0;i<16;i++)
 135   3            {
 136   4              sum += cap_res_g[i];
 137   4            }
 138   3            cap_res_lp = sum>>4;
 139   3            if(cap_res_lp<1100)
 140   3            {
 141   4              PWM_Set = 25;
 142   4            }
 143   3            else if(cap_res_lp>1900)
 144   3            {
 145   4              UartSendStr("over\r\n");
 146   4              PWM_Set = 230;
 147   4            }
 148   3            else if((cap_res_lp>=1100) && (cap_res_lp <= 1900))
 149   3            {
 150   4              UartSendStr("enable\r\n");
 151   4              PWM_Set = (u8)((cap_res_lp - 1000)>>2);
 152   4            }
 153   3            
 154   3            
 155   3            if(pwmb_it_flag)
 156   3            {
 157   4              u8 ch;
 158   4              u16 tmp;
 159   4              pwmb_it_flag = 0;
 160   4              UartSend(0xff);
 161   4              /*
 162   4              tmp = dtmp;
 163   4              ch = (u8)(tmp>>8);
 164   4              UartSend(ch);
 165   4              ch = (u8)tmp;
 166   4              UartSend(ch);
 167   4              tmp = uptmp;
 168   4              ch = (u8)(tmp>>8);
 169   4              UartSend(ch);
 170   4              ch = (u8)tmp;
 171   4              UartSend(ch);
 172   4              */
 173   4              tmp = cap_res_lp;
 174   4              ch = (u8)(tmp>>8);
 175   4              UartSend(ch);
 176   4              ch = (u8)tmp;
 177   4              UartSend(ch);
 178   4              
C51 COMPILER V9.60.0.0   MAIN                                                              01/15/2023 19:33:59 PAGE 4   

 179   4              UartSend(0xff);
 180   4            }
 181   3            
 182   3          }
 183   2        }
 184   1      }
 185          
 186          void Port_Init(void)
 187          {
 188   1        P0M0 = 0x00;
 189   1        P0M1 = 0x00; //P0端口初始化为双向口
 190   1        P1M0 = 0x00;
 191   1        P1M1 = 0x00; //P1端口初始化为双向口
 192   1        P2M0 = 0x00;
 193   1        P2M1 = 0x00; //P2端口初始化为双向口
 194   1        P3M0 = 0x00;
 195   1        P3M1 = 0x00; //P3端口初始化为双向口
 196   1        P5M0 = 0x00;
 197   1        P5M0 = 0x00; //P5端口初始化为双向口
 198   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1696    ----
   CONSTANT SIZE    =     41    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     83      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      7    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
