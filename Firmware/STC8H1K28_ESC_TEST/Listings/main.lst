C51 COMPILER V9.60.0.0   MAIN                                                              01/14/2023 20:28:46 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil51\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main.
                    -lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "stc8h.h"
   2          #include <intrins.h>
   3          
   4          /*
   5           * PWM1P1.0PWMƵUλMOSѡͨźţߵƽͨ͵ƽֹ
   6           * PWM1_LP1.1ƵUλMOSѡͨźţߵƽͨ͵ƽֹ
   7           * PWM2P1.2PWMƵVλMOSѡͨźţߵƽͨ͵ƽֹ
   8           * PWM2_LP1.3ƵVλMOSѡͨźţߵƽͨ͵ƽֹ
   9           * PWM3P1.4PWMƵWλMOSѡͨźţߵƽͨ͵ƽֹ
  10           * PWM3_LP1.5ƵWλMOSѡͨźţߵƽͨ͵ƽֹ
  11           * ADC8P0.0ø룬UӦ綯ƣڹȽ
  12           * ADC9P0.1ø룬VӦ綯
  13           * ADC10P0.2ø룬WӦ綯
  14           * CMP-P3.6Ϊ룬ӹ·е
  15          */
  16          
  17          /*
  18           * ˢͨ
  19           * AB-AC-BC-BA-CA-CB-AB
  20           * ӦӦ綯Ʊ仯
  21           * C½-B-A½-C-B½-A-C½
  22          */
  23          
  24          #define FOSC 24000000UL //ϵͳʱ
  25          #define BRT (65536-(FOSC/115200+2)/4) //תֵ
  26          
  27          typedef unsigned char u8;
  28          typedef unsigned int u16;
  29          typedef unsigned long u32;
  30          
  31          #define PWM1    P10
  32          #define PWM1_L  P11
  33          #define PWM2    P12
  34          #define PWM2_L  P13
  35          #define PWM3    P14
  36          #define PWM3_L  P15
  37          
  38          #define ADC_START (1<<6)  //ADӿƼĴbit6ADCתλд1ʼADCת
  39          #define ADC_FLAG (1<<5) //ADCƼĴbit5ADCת־λ
  40          #define ADC_SPEED 1     //ADCüĴbit3~bit0ADCʱƵ
  41          #define RES_FMT (1<<5)  //ADCüĴbit51ADCҶ룬0ADC
  42          #define CSSETUP (0<<7)  //ADCTIMʱƼĴͨѡʱλbit7ռһʱ
  43          #define CSHOLD (1<<5)   //ADCTIMʱƼĴͨʱλbit6~bit5ռ2ʱ
  44          #define SMPDUTY 20      //ADCTIMʱƼĴͨʱλbit4~bit0ռ21ʱС10
  45          
  46          #define RX_LEN 16 //ڽݻ泤
  47          bit busy;   //ڷɱ־
  48          char wptr;  //ڽݳ
  49          char buffer[RX_LEN]; //ڽݻ
  50          
  51          void Port_Init(void); //оƬλųʼ
  52          void PWMA_Config(void); //PWMAú
  53          void ADC_Config(void);  //ADCú
  54          void CMP_Config(void);  //Ƚú
C51 COMPILER V9.60.0.0   MAIN                                                              01/14/2023 20:28:46 PAGE 2   

  55          void Timer0_Config(void); //ʱ0úѿʱ0жϣ4msһΣ
  56          void Timer3_Config(void); //ʱ3ú
  57          void Timer4_Config(void); //ʱ4ú
  58          
  59          #define delay_200ns() do{_nop_();_nop_();_nop_();_nop_();}while(0) //MOSֲʱ䣬ֲõMO
             -SܵͨضʱΪ55ns˴Ϊ200nsʱ
  60          #define delay_dead() delay_200ns()
  61          u16 Get_ADCRes(u8 ch);  //ȡADCָͨ
  62          void Motor_Start(void); //
  63          void Motor_Step(void); //ຯ
  64          
  65          void  Delay_n_ms(u8 dly)  // N msʱ
  66          {
  67   1        u16 j;
  68   1        do
  69   1        {
  70   2          j = FOSC / 10000;
  71   2          while(--j)  ;
  72   2        }while(--dly);
  73   1      }
  74          
  75          void delay_us(u8 us)  //N usʱ
  76          {
  77   1        do
  78   1        {
  79   2          _nop_();
  80   2          _nop_();
  81   2          _nop_();
  82   2          _nop_();
  83   2          _nop_();
  84   2          _nop_();
  85   2          _nop_();
  86   2          _nop_();
  87   2          _nop_();
  88   2          _nop_();
  89   2          _nop_();
  90   2          _nop_();
  91   2          _nop_();
  92   2          _nop_();
  93   2          _nop_();
  94   2          _nop_();
  95   2          _nop_();
  96   2          _nop_();
  97   2          _nop_();
  98   2          _nop_();  //@24MHz
  99   2        }
 100   1        while(--us);
 101   1      }
 102          
 103          //ú
 104          void Uart_Config(void); //ڳʼ
 105          void UartSend(char dat); //ڷֽ
 106          void UartSendStr(char *p); //ڷַ
 107          void UartSendNum(int num); //ڷ-32767~32768Χڵ
 108          
 109          u8 step; //ͨţ࣬Χ0~5
 110          bit m_starting; //־
 111          bit m_running;  //б־
 112          u8 demagnetizing_cnt; //żֵ1ΪҪţ2Ϊţ0ΪѾţʼΪ0кȽж
             -¼1ڼûʱ䣩ڶʱ4жϻ
 113          bit t3_flag; //Timer3־32.768ms1һ
 114          bit t0_flag; //Timer0־4ms1һ
C51 COMPILER V9.60.0.0   MAIN                                                              01/14/2023 20:28:46 PAGE 3   

 115          #define TMP_LEN 8
 116          u8 time_index;
 117          u16 phase_time_tmp[TMP_LEN];
 118          u8 timeout;
 119          u8  PWM_Value;  // PWMռձȵֵ
 120          u8  PWM_Set;  //ĿPWM
 121          #define D_START_PWM   30
 122          
 123          //ò
 124          bit cmp_it_flag;
 125          u16 debug_phase_time;
 126          bit t4_it_flag1;
 127          bit t4_it_flag2;
 128          
 129          void UartIsr() interrupt 4
 130          {
 131   1        if(TI)
 132   1        {
 133   2          TI = 0;
 134   2          busy = 0;
 135   2        }
 136   1        if(RI)
 137   1        {
 138   2          RI = 0;
 139   2          buffer[wptr++] = SBUF;
 140   2          if(SBUF == '\n')
 141   2            wptr |= 0x80;
 142   2        }
 143   1      }
 144          
 145          void UartRxTest(void)
 146          {
 147   1        if(wptr & 0x80)
 148   1        {
 149   2          unsigned char len = wptr & 0x7f;
 150   2          u8 i;
 151   2          UartSendStr(buffer);
 152   2          for(i = 0;i<len;i++)
 153   2            buffer[i] = 0;
 154   2          wptr = 0;
 155   2        }
 156   1      }
 157          
 158          void main(void)
 159          {
 160   1        u8  i;
 161   1        u16 j;
 162   1        
 163   1        P_SW2 |= 0x80; //ʹXFR
 164   1        
 165   1        Port_Init();  //ö˿ڳʼ
 166   1        PWMA_Config();  //PWMAʼ
 167   1        ADC_Config(); //ADCʼ
 168   1        CMP_Config(); //ģȽʼ
 169   1        Timer0_Config();  //öʱ0ʼ
 170   1        Timer3_Config();  //öʱ3ʼ
 171   1        Timer4_Config();  //öʱ4ʼ
 172   1        
 173   1        Uart_Config();  //ôڳʼ
 174   1        ES = 1;
 175   1        
 176   1        PWM_Set = 100;
C51 COMPILER V9.60.0.0   MAIN                                                              01/14/2023 20:28:46 PAGE 4   

 177   1        timeout = 0;
 178   1        
 179   1        EA = 1; //ж
 180   1        
 181   1        UartSendStr("--Brushless ESC Test--\r\n");
 182   1        
 183   1        //PWMA_ENO = 0x15; //0x15 = 0b0001 0101PWMAܣʹPWM1PPWM2PPWM3P
 184   1        
 185   1        while(1)
 186   1        {
 187   2          if(t0_flag)
 188   2          {
 189   3            t0_flag = 0;
 190   3            if(timeout != 0)
 191   3            {
 192   4              if(--timeout == 0)
 193   4              {
 194   5                UartSendStr("timeout\r\n");
 195   5                m_running = 0;
 196   5                PWM_Value = 0;
 197   5                CMPCR1 = 0x8c;
 198   5                PWMA_ENO = 0;
 199   5                PWMA_CCR1 = 0;
 200   5                PWMA_CCR2 = 0;
 201   5                PWMA_CCR3 = 0;
 202   5                PWM1_L = 0;
 203   5                PWM2_L = 0;
 204   5                PWM3_L = 0;
 205   5                Delay_n_ms(250);
 206   5              }
 207   4            }
 208   3            if(!m_running && (PWM_Set >= D_START_PWM))
 209   3            {
 210   4              UartSendStr("-ST-\r\n");
 211   4              m_starting = 1;
 212   4              for(i = 0;i<8;i++) phase_time_tmp[i] = 400; 
 213   4              Motor_Start();
 214   4              m_starting = 0;
 215   4              demagnetizing_cnt = 0;
 216   4              CMPCR1 &= ~0x40;
 217   4              if(step & 1)  CMPCR1 = 0xAC;    //ж
 218   4              else      CMPCR1 = 0x9C;    //½ж
 219   4              m_running = 1;
 220   4              Delay_n_ms(250);  //ʱһ, 
 221   4              Delay_n_ms(250);
 222   4              timeout = 125;    //ʱʱ 125*4 = 500ms
 223   4            }
 224   3            if(m_running)
 225   3            {
 226   4              if(PWM_Value < PWM_Set) PWM_Value++;
 227   4              if(PWM_Value > PWM_Set) PWM_Value--;
 228   4              PWMA_CCR1 = PWM_Value;
 229   4              PWMA_CCR2 = PWM_Value;
 230   4              PWMA_CCR3 = PWM_Value;
 231   4            }
 232   3            if(cmp_it_flag)
 233   3            {
 234   4              cmp_it_flag = 0;
 235   4              UartSendStr("-cmp it-\r\n");
 236   4              UartSendStr("ph:");
 237   4              UartSendNum(debug_phase_time);
 238   4              UartSendStr("\r\n");
C51 COMPILER V9.60.0.0   MAIN                                                              01/14/2023 20:28:46 PAGE 5   

 239   4            }
 240   3            if(t4_it_flag1)
 241   3            {
 242   4              t4_it_flag1 = 0;
 243   4              UartSendStr("-t4 it 1-\r\n");
 244   4            }
 245   3            if(t4_it_flag2)
 246   3            {
 247   4              t4_it_flag2 = 0;
 248   4              UartSendStr("-t4 it 2-\r\n");
 249   4            }
 250   3          }
 251   2        }
 252   1      }
*** WARNING C280 IN LINE 161 OF main.c: 'j': unreferenced local variable
 253          
 254          void Port_Init(void)
 255          {
 256   1        P0M0 = 0x00;
 257   1        P0M1 = 0x00; //P0˿ڳʼΪ˫
 258   1        P1M0 = 0x00;
 259   1        P1M1 = 0x00; //P1˿ڳʼΪ˫
 260   1        P2M0 = 0x00;
 261   1        P2M1 = 0x00; //P2˿ڳʼΪ˫
 262   1        P3M0 = 0x00;
 263   1        P3M1 = 0x00; //P3˿ڳʼΪ˫
 264   1        P5M0 = 0x00;
 265   1        P5M0 = 0x00; //P5˿ڳʼΪ˫
 266   1      }
 267          
 268          void PWMA_Config(void)
 269          {
 270   1        //ȽMOSѡͨźֹͣͨ
 271   1        PWM1 = 0;
 272   1        PWM1_L = 0;
 273   1        PWM2 = 0;
 274   1        PWM2_L = 0;
 275   1        PWM3 = 0;
 276   1        PWM3_L = 0;
 277   1        
 278   1        //ѡͨΪM0ӦbitΪ1M1ӦbitΪ0
 279   1        P1M0 |= 0x3f; //0x3f = 0B0011 1111bit0~bit51
 280   1        P1M1 &= ~0x3f; //~0x3f = 0B1100 0000,bit0~bit50
 281   1        
 282   1        PWMA_PSCR = 3;  //PWMA_PSCRΪPWMA16λԤƵĴ16λݶдf_ck_int = f_ck_psc/(PSCR[15:0]+1
             -)
 283   1        PWMA_DTR = 24;  //PWMA_DTRλPWMAĴʱ䣬δ
 284   1        
 285   1        PWMA_ARR = 0xff;  //PWMA_ARRΪPWMA16λԶؼĴ
 286   1        PWMA_CCER1 = 0; ///ȽʹܼĴ1üԼʹ
 287   1        PWMA_CCER2 = 0; ///ȽʹܼĴ2üԼʹ
 288   1        PWMA_SR1 = 0;   //״̬Ĵ1жϱ
 289   1        PWMA_SR2 = 0;   //״̬Ĵ2ظ
 290   1        PWMA_ENO = 0;   //ʹܼĴ
 291   1        PWMA_PS = 0;    //ܽл
 292   1        PWMA_IER = 0;   //жʹܼĴ
 293   1        
 294   1        PWMA_CCMR1 = 0x68;  ///ȽģʽĴ10x68 = 0b0110 1000ΪԤװأPWMģʽ1
 295   1        PWMA_CCR1 = 0x00;     ///ȽϼĴ16λǰȽֵ
 296   1        PWMA_CCER1 |= 0x01; ///ȽʹܼĴ1ԭ0x05 = 0b0000 0101,ָΪ0x01ʹOC1
 297   1        PWMA_PS |= 0;       //PWMA IOѡ
 298   1        
C51 COMPILER V9.60.0.0   MAIN                                                              01/14/2023 20:28:46 PAGE 6   

 299   1        PWMA_CCMR2 = 0x68;  ///ȽģʽĴ20x68 = 0b0110 1000ΪԤװأPWMģʽ1
 300   1        PWMA_CCR2 = 0x00;     ///ȽϼĴ16λǰȽֵPWMA_ARRȽ
 301   1        PWMA_CCER1 |= 0x10; ///ȽʹܼĴ1ԭ0x50 = 0b0101 0000ָΪ0x10ʹOC2
 302   1        PWMA_PS |= (0<<2);  //PWMA IOѡ
 303   1        
 304   1        PWMA_CCMR3 = 0x68;  ///ȽģʽĴ30x68 = 0b0110 1000ΪԤװأPWMģʽ1
 305   1        PWMA_CCR3 = 0x00;     ///ȽϼĴ16λǰȽֵ
 306   1        PWMA_CCER2 |= 0x01; ///ȽʹܼĴ2ԭ0x05 = 0b0000 0101,ָΪ0x01ʹOC3
 307   1        PWMA_PS |= (0<<4);  //PWMA IOѡ
 308   1        
 309   1        PWMA_BKR = 0x80;  //ʹOCOCN
 310   1        PWMA_CR1 = 0x81;  //ƼĴ1ʹԶԤװأض룬ϼʹܼ
 311   1        PWMA_EGR = 0x01;  //ʼ
 312   1      }
 313          
 314          void ADC_Config(void)
 315          {
 316   1        //ģʽΪ룬M1ӦbitΪ1M0ӦbitΪ0
 317   1        P1M1 |= 0xc0; //־λ1
 318   1        P1M0 &= ~0xc0; //־λ0
 319   1        
 320   1        //ģʽΪ룬M1ӦbitΪ1M0ӦbitΪ0
 321   1        P0M1 |= 0x0f;  //־λ1
 322   1        P0M0 &= ~0x0f; //־λ0
 323   1        
 324   1        ADC_CONTR = 0x80+6; //ADCƼĴbit71ADCԴbit3~bit0ΪͨѡλSTC8H1K28ϵADC12~ADC1
             -4.STC8H1K08ϵADC2~ADC7
 325   1        ADCCFG = RES_FMT + ADC_SPEED; //ADCüĴbit5ʽƣ0룬1Ҷ룬bit3~bit0ADCʱ
             -Ƶʣf=Sysclk/2/(speed+1)
 326   1        ADCTIM = CSSETUP + CSHOLD + SMPDUTY;  //ADCʱƼĴbit7T_setup | bit6~bit5T_hold | bit4~bit0
             -T_duty
 327   1      }
 328          
 329          void CMP_Config(void)
 330          {
 331   1        //CMP-Ϊ룬M1ӦbitΪ1M0ӦbitΪ0
 332   1        P3M1 |= 0x40; //0x40 = 0b0100 0000,bit61
 333   1        P3M0 &= ~0x40; //~0x40 = 0b1011 1111bit60
 334   1        
 335   1        CMPCR1 = 0x8C;  //ȽƼĴ1bit7ģʹܣbit6жϱ־λbit5жʹܣbit4½жʹ
 336   1                        //bit3ѡbit2ѡbit1ƣbit0ȽϽ
 337   1                        //0x80 = 0b1000 1100ʹܱȽADCΪ룬P3.6Ϊ
 338   1        CMPCR2 = 60; //ȽƼĴ2bit7ƣbit6ģ˲ƣ0ʹܣbit5~bit0˲ʱ
 339   1      }
 340          
 341          void Timer0_Config(void)
 342          {
 343   1        TMOD &= ~0x03;    //ʱ0/1ģʽĴ~0x03 = 0b1111 1100bit1~bit0㣬ʱ0Ϊ16λԶģʽ
 344   1        AUXR &= ~(1<<7);  //Ĵ1bit70ʱ0ʱΪCPUʱ12Ƶ24MHz/12 = 2MHz
 345   1        
 346   1        //12Ƶ£ʱ=(65536-[TH0,TL0])*12/FOSC,4msʱ= 0.004 = 1/250
 347   1        TH0 = (65536UL - FOSC / 12 / 250)>>8; //ʱ0Ĵ
 348   1        TL0 = (u8)(65536UL - FOSC / 12 / 250); //ʱ0Ĵ
 349   1        TR0 = 1;  //ʱ0
 350   1        ET0 = 1;  //ʹܶʱ0ж
 351   1      }
 352          
 353          void Timer3_Config(void)
 354          {
 355   1        T4T3M &= 0xf0;  //ʱ3/4ƼĴ4λʱ44λʱ34λ㣬ʱ3ֹͣʱ
             -12Ƶرʱ
 356   1        T3H = 0;  //ʱ3Ĵ
C51 COMPILER V9.60.0.0   MAIN                                                              01/14/2023 20:28:46 PAGE 7   

 357   1        T3L = 0;  //ʱ3Ĵ
 358   1        
 359   1        T3T4PIN = 0x01; //ʱ3/4лĴbit0ѡλ1ѡP0.0P0.1P0.2P0.3
 360   1        IE2 |= (1<<5);  //жʹܼĴ2bit5Ϊʱ3жλ1ж
 361   1        T4T3M |= (1<<3);  //ʱ3/4ƼĴbit31ʱ3ʼ
 362   1      }
 363          
 364          void Timer4_Config(void)
 365          {
 366   1        T4T3M &= 0x0f; //ʱ3/4ƼĴ4λʱ44λʱ34λ㣬ʱ4ֹͣʱ
             -12Ƶرʱ
 367   1        T4H = 0;  //ʱ4Ĵ
 368   1        T4L = 0;  //ʱ4Ĵ
 369   1        
 370   1        //T4H = (u8)((65536UL - 40*2) >> 8);  //ãʱ4ƵΪ2MHz40usҪ80
 371   1        //T4L = (u8)(65536UL - 40*2); //
 372   1        
 373   1        T3T4PIN = 0x01; //ʱ3/4лĴbit0ѡλ1ѡP0.0P0.1P0.2P0.3
 374   1        IE2 |= (1<<6);  //жʹܼĴ2bit6Ϊʱ4жλ1ж
 375   1        //T4T3M |=  (1<<7); //ʼ
 376   1      }
 377          
 378          u16 Get_ADCRes(u8 ch)
 379          {
 380   1        u8 i = 255; //ADCתʱģʱ
 381   1        ADC_RES = 0;  //ADCתĴ
 382   1        ADC_RESL = 0; //ADCתĴL
 383   1        ADC_CONTR = 0x80|ADC_START|ch; //ѡADCͨʼת
 384   1        _nop_();
 385   1        while(i != 0)
 386   1        {
 387   2          i--;
 388   2          if((ADC_CONTR & ADC_FLAG) != 0) break;  //ȴADC
 389   2        }
 390   1        ADC_CONTR &= ~ADC_FLAG; //תɱ־λ
 391   1        return  ((u16)ADC_RES>>8 + (u16)ADC_RESL); //ضȡ
 392   1      }
 393          
 394          void Motor_Start(void)
 395          {
 396   1        u16 timer,i;
 397   1        CMPCR1 = 0x8C;  // رȽж
 398   1      
 399   1        PWM_Value  = D_START_PWM; // ʼռձ, ݵ
 400   1        PWMA_CCR1L = PWM_Value;
 401   1        PWMA_CCR2L = PWM_Value;
 402   1        PWMA_CCR3L = PWM_Value;
 403   1        step = 0;
 404   1        Motor_Step();
 405   1        Delay_n_ms(50);
 406   1        //Delay_n_ms(250);// ʼλ
 407   1        timer = 200;  //ȵ
 408   1      
 409   1        while(1)
 410   1        {
 411   2          for(i=0; i<timer; i++)  delay_us(100);  //ݵ, תٵȵȵٶ
 412   2          timer -= timer /16;
 413   2          if(++step >= 6) step = 0;
 414   2          Motor_Step();
 415   2          if(timer < 40)  return;
 416   2        }
 417   1      }
C51 COMPILER V9.60.0.0   MAIN                                                              01/14/2023 20:28:46 PAGE 8   

 418          
 419          //ຯ
 420          //ݵͨţͨ
 421          void Motor_Step(void)
 422          {
 423   1        switch(step)
 424   1        {
 425   2          case 0: //ABͨ磬ڼCӦ綯ɸ仯AϹܵͨB¹ܵͨMOSܹض
 426   2            PWMA_ENO = 0x00; //رPWMرһCϹܵͨȹضϣȻAϹ
 427   2            PWM1_L = 0; //A¹ܹض
 428   2            PWM3_L = 0; //C¹ܹض
 429   2            delay_dead(); //ӳ٣ֹACϹͬʱͨ
 430   2            PWMA_ENO = 0x01; //AϹPWM
 431   2            PWM2_L = 1; //B¹ܵͨ
 432   2            ADC_CONTR = 0x80+10; //ѡADC10P0.2
 433   2            if(m_running) CMPCR1 = 0x8c + 0x10; //Ƚ½жʹ
 434   2            else CMPCR1 = 0x8c; //ʱرձȽж
 435   2            break;
 436   2          case 1: //ACͨ磬ڼBӦ綯仯AϹܵͨC¹ܵͨMOSܹض
 437   2            PWMA_ENO = 0x01;  //AϹܵͨ
 438   2            PWM1_L = 0; //A¹ܹض
 439   2            PWM2_L = 0; //B¹ܹض
 440   2            delay_dead(); //ӳ٣ֹBC¹ͬʱͨ
 441   2            PWM3_L = 1; //C¹ܵͨ
 442   2            ADC_CONTR = 0x80 + 9; //ѡADC9P0.1
 443   2            if(m_running) CMPCR1 = 0x8c + 0x20; //Ƚжʹ
 444   2            else CMPCR1 = 0x8c; //ʱرձȽж
 445   2            break;
 446   2          case 2: //BCͨ磬ڼAӦ綯ɸ仯BϹܵͨC¹ܵͨMOSܹض
 447   2            PWMA_ENO = 0x00; //رPWMرһAϹܵͨȹضϣȻܿBϹ
 448   2            PWM1_L = 0; //A¹ܹض
 449   2            PWM2_L = 0; //B¹ܹض
 450   2            delay_dead();
 451   2            PWMA_ENO = 0x04;  //BϹPWM
 452   2            PWM3_L = 1; //C¹ܵͨ
 453   2            ADC_CONTR = 0x80+8;   //ѡADC8P0.0
 454   2            if(m_running) CMPCR1 = 0x8c + 0x10; //Ƚ½жʹ
 455   2            else CMPCR1 = 0x8c; //ʱرձȽж
 456   2            break;
 457   2          case 3: //BAͨ磬ڼCӦ綯仯BϹܵͨA¹ܵͨMOSܹض
 458   2            PWMA_ENO = 0x04;  //BϹܣرACϹ
 459   2            PWM2_L = 0; //B¹ܹض
 460   2            PWM3_L = 0; //C¹ܹض
 461   2            delay_dead(); //ʱAC¹
 462   2            PWM1_L = 1; //A¹ܵͨ
 463   2            ADC_CONTR = 0x80 + 10;  //ѡADC10P0.2
 464   2            if(m_running) CMPCR1 = 0x8c + 0x20; //Ƚжʹ
 465   2            else CMPCR1 = 0x8c; //ʱرձȽж
 466   2            break;
 467   2          case 4: //CAͨ磬ڼBӦ綯ɸ仯CϹܵͨA¹ܵͨMOSܹض
 468   2            PWMA_ENO = 0x00;  //رϹPWMֹBCϹͬʱͨ
 469   2            PWM2_L = 0; //B¹ܹض
 470   2            PWM3_L = 0; //C¹ܹض
 471   2            delay_dead(); //ʱBCϹ
 472   2            PWMA_ENO = 0x10;  //ʹCϹPWM
 473   2            PWM1_L = 1; //A¹ܵͨ
 474   2            ADC_CONTR = 0x80+9; //ADC9P0.1
 475   2            if(m_running) CMPCR1 = 0x8c + 0x10; //Ƚ½жʹ
 476   2            else CMPCR1 = 0x8c; //ʱرձȽж
 477   2            break;
 478   2          case 5: //CBͨ磬ڼAӦ綯仯CϹܵͨB¹ܵͨMOSܹض
 479   2            PWMA_ENO = 0x10;  //ʹCϹPWM
C51 COMPILER V9.60.0.0   MAIN                                                              01/14/2023 20:28:46 PAGE 9   

 480   2            PWM1_L = 0; //A¹ܹض
 481   2            PWM3_L = 0; //C¹ܹض
 482   2            delay_dead(); //ʱAB¹
 483   2            PWM2_L = 1; //B¹ܵͨ
 484   2            ADC_CONTR = 0x80 + 8; //ADC8P0.0
 485   2            if(m_running) CMPCR1 = 0x8c + 0x20; //Ƚжʹ
 486   2            else CMPCR1 = 0x8c; //ʱرձȽж
 487   2            break;
 488   2          default:
 489   2            break;
 490   2        }
 491   1      }
 492          
 493          void Uart_Config(void)
 494          {
 495   1        SCON = 0x50;
 496   1        T2L = BRT;
 497   1        T2H = BRT>>8;
 498   1        AUXR = 0x15;
 499   1        wptr = 0;
 500   1        busy = 0;
 501   1      }
 502          
 503          void UartSend(char dat)
 504          {
 505   1        while(busy);
 506   1        busy = 1;
 507   1        SBUF = dat;
 508   1      }
 509          
 510          void UartSendStr(char *p)
 511          {
 512   1        while(*p)
 513   1        {
 514   2          UartSend(*p++);
 515   2        }
 516   1      }
 517          
 518          void UartSendNum(int num)
 519          {
 520   1        char buf[8];
 521   1        u8 dat;
 522   1        u8 i = 0;
 523   1        if(num<0)
 524   1        {
 525   2          UartSend('-');
 526   2          num = -num;
 527   2        }
 528   1        while(num)
 529   1        {
 530   2          dat = num%10;
 531   2          buf[i] = dat + 0x30;
 532   2          num /= 10;
 533   2          i++;
 534   2        }
 535   1        UartSendStr(buf);
 536   1      }
 537          
 538          //ȽжϺ
 539          //⵽¼󣬸ݶʱ3ļֵһι¼ʱ
 540          //8λʱ16ÿλʱ䣬Ϊ´λʱ
 541          void CMP_ISR(void) interrupt 21
C51 COMPILER V9.60.0.0   MAIN                                                              01/14/2023 20:28:46 PAGE 10  

 542          {
 543   1        u16 phase_time;
 544   1        u8 i;
 545   1        
 546   1        CMPCR1 %= ~0x40; //жϱ־λ
 547   1        
 548   1        if(demagnetizing_cnt == 0) //ź¼δŲȽж
 549   1        {
 550   2          T4T3M &= ~(1<<3); //Timer3ֹͣ
 551   2          if(t3_flag)
 552   2          {
 553   3            t3_flag = 0;
 554   3            phase_time = 0x1fff;
 555   3          }
 556   2          else
 557   2          {
 558   3            phase_time = (((u16)T3H<<8)+(u16)T3L)>>1;
 559   3            phase_time &= 0x1ffff;
 560   3          }
 561   2          T3H = 0;
 562   2          T3L = 0;
 563   2          T4T3M |= (1<<3);
 564   2          
 565   2          phase_time_tmp[time_index] = phase_time;
 566   2          if(++time_index >=8) time_index = 0;
 567   2          for(phase_time = 0,i = 0;i<8;i++)
 568   2          {
 569   3            phase_time += phase_time_tmp[i];
 570   3          }
 571   2          phase_time >>= 4;
 572   2          debug_phase_time = phase_time;
 573   2          if(phase_time > 40 && phase_time < 1000)
 574   2          {
 575   3            cmp_it_flag = 1;
 576   3            timeout = 125;
 577   3          }
 578   2          if(phase_time > 40) phase_time -= 40;
 579   2          else phase_time = 20;
 580   2          
 581   2          T4T3M &= ~(1<<7);
 582   2          phase_time = phase_time << 1;
 583   2          phase_time = 0 - phase_time;
 584   2          T4H = (u8)(phase_time >> 8);
 585   2          T4L = (u8)phase_time;
 586   2          T4T3M |= (1<<7);
 587   2          demagnetizing_cnt = 1;
 588   2        }
 589   1      }
 590          
 591          void Timer0_ISR(void) interrupt 1
 592          {
 593   1        //PWM1 = !PWM1; //ʱ0жϲԣתPWM1ŵƽ
 594   1        t0_flag = 1;
 595   1      }
 596          
 597          void Timer3_ISR(void) interrupt 19
 598          {
 599   1        //PWM2 = !PWM2; //ʱ3зֶβԣתPWM2ŵƽ
 600   1        t3_flag = 1;
 601   1      }
 602          
 603          //öʱ4ţԭ򻯳ɶʱ˴Ϊ40usʱԽʱԽ
C51 COMPILER V9.60.0.0   MAIN                                                              01/14/2023 20:28:46 PAGE 11  

 604          //󣬶ϵһ࣬ȦĴڻԸе綯ƣţȽڷǸӦ綯ƹʱ
             -
 605          //˴޸demagnetzing_cntżֵıȽж
 606          void Timer4_ISR(void) interrupt 20
 607          {
 608   1        T4T3M &= ~(1<<7); //ʱ3/4ƼĴbit70ʱ4ֹͣ
 609   1        
 610   1        if(demagnetizing_cnt == 1)  //жżֵΪ1ΪҪ
 611   1        {
 612   2          demagnetizing_cnt = 2;  //żֵΪ2Ȼ࣬ٽ
 613   2          if(m_running)
 614   2          {
 615   3            t4_it_flag1 = 1;
 616   3            if(++step >= 6) step = 0;
 617   3            Motor_Step();
 618   3          }
 619   2          
 620   2          T4H = (u8)((65536UL - 40*2) >> 8);  //40us(65536 - t *2)tλus8λT4H8λT4L
 621   2          T4L = (u8)(65536UL - 40*2); //40us
 622   2          T4T3M |=  (1<<7); //Timer4ʼ
 623   2        }
 624   1        else if(demagnetizing_cnt == 2)
 625   1        {
 626   2          t4_it_flag2 = 1;
 627   2          demagnetizing_cnt = 0;
 628   2        }
 629   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1573    ----
   CONSTANT SIZE    =     84    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     41      19
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      8    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
