C51 COMPILER V9.60.0.0   MAIN                                                              01/14/2023 20:51:33 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil51\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main.
                    -lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #define MAIN_Fosc   24000000L //¶¨ÒåÖ÷Ê±ÖÓ
   2          
   3          #include  "STC8Hxxx.h"
   4          
   5          
   6          #define ADC_START (1<<6)  /* ×Ô¶¯Çå0 */
   7          #define ADC_FLAG  (1<<5)  /* Èí¼þÇå0 */
   8          
   9          #define ADC_SPEED 1   /* 0~15, ADCÊ±ÖÓ = SYSclk/2/(n+1) */
  10          #define RES_FMT   (1<<5)  /* ADC½á¹û¸ñÊ½ 0: ×ó¶ÔÆë, ADC_RES: D9 D8 D7 D6 D5 D4 D3 D2, ADC_RESL: D1 D0 0  0  
             -0  0  0  0 */
  11                        /*             1: ÓÒ¶ÔÆë, ADC_RES: 0  0  0  0  0  0  D9 D8, ADC_RESL: D7 D6 D5 D4 D3 D2 D1 D0 */
  12          
  13          #define CSSETUP   (0<<7)  /* 0~1,  ADCÍ¨µÀÑ¡ÔñÊ±¼ä      0: 1¸öADCÊ±ÖÓ, 1: 2¸öADCÊ±ÖÓ,  Ä¬ÈÏ0(Ä¬ÈÏ1¸öADCÊ±ÖÓ)
             - */
  14          #define CSHOLD    (1<<5)  /* 0~3,  ADCÍ¨µÀÑ¡Ôñ±£³ÖÊ±¼ä  (n+1)¸öADCÊ±ÖÓ, Ä¬ÈÏ1(Ä¬ÈÏ2¸öADCÊ±ÖÓ)                
             -*/
  15          #define SMPDUTY   20    /* 10~31, ADCÄ£ÄâÐÅºÅ²ÉÑùÊ±¼ä  (n+1)¸öADCÊ±ÖÓ, Ä¬ÈÏ10(Ä¬ÈÏ11¸öADCÊ±ÖÓ)        */
  16                        /* ADC×ª»»Ê±¼ä: 10Î»ADC¹Ì¶¨Îª10¸öADCÊ±ÖÓ, 12Î»ADC¹Ì¶¨Îª12¸öADCÊ±ÖÓ.         */
  17          
  18          sbit PWM1   = P1^0;
  19          sbit PWM1_L = P1^1;
  20          sbit PWM2   = P1^2;
  21          sbit PWM2_L = P1^3;
  22          sbit PWM3   = P1^4;
  23          sbit PWM3_L = P1^5;
  24          
  25          u8  step;   //ÇÐ»»²½Öè
  26          u8  PWM_Value;  // ¾ö¶¨PWMÕ¼¿Õ±ÈµÄÖµ
  27          bit B_RUN;    //ÔËÐÐ±êÖ¾
  28          u8  PWW_Set;  //Ä¿±êPWMÉèÖÃ
  29          bit B_4ms;    //4ms¶¨Ê±±êÖ¾
  30          
  31          u8  TimeOut;  //¶Â×ª³¬Ê±
  32          bit B_start;  //Æô¶¯Ä£Ê½
  33          bit B_Timer3_OverFlow;
  34          
  35          u8  TimeIndex;    //»»ÏàÊ±¼ä±£´æË÷Òý
  36          u16 PhaseTimeTmp[8];//8¸ö»»ÏàÊ±¼ä, Æä sum/16 ¾ÍÊÇ30¶Èµç½Ç¶È
  37          u16 PhaseTime;    //»»ÏàÊ±¼ä¼ÆÊý
  38          u8  XiaoCiCnt;    //1:ÐèÒªÏû´Å, 2:ÕýÔÚÏû´Å, 0ÒÑ¾­Ïû´Å
  39          
  40          
  41          /*************************/
  42          
  43          void  Delay_n_ms(u8 dly)  // N msÑÓÊ±º¯Êý
  44          {
  45   1        u16 j;
  46   1        do
  47   1        {
  48   2          j = MAIN_Fosc / 10000;
  49   2          while(--j)  ;
  50   2        }while(--dly);
  51   1      }
C51 COMPILER V9.60.0.0   MAIN                                                              01/14/2023 20:51:33 PAGE 2   

  52          
  53          void delay_us(u8 us)  //N usÑÓÊ±º¯Êý
  54          {
  55   1        do
  56   1        {
  57   2          NOP(20);  //@24MHz
  58   2        }
  59   1        while(--us);
  60   1      }
  61          
  62          void  Delay_500ns(void)
  63          {
  64   1        NOP(6);
  65   1      }
  66          
  67          #define delay_200ns() do{_nop_();_nop_();_nop_();_nop_();}while(0) //¸ù¾ÝMOS¹ÜÊÖ²áµ÷ÕûËÀÇøÊ±¼ä£¬ÏÖ²ÉÓÃµÄMO
             -S¹Üµ¼Í¨¹Ø¶ÏÊ±¼ä×î´óÎª55ns£¬´Ë´¦µ÷ÕûÎª200nsÑÓÊ±
  68          #define delay_dead() delay_200ns()
  69          
  70          void StepMotor(void) // »»ÏàÐòÁÐº¯Êý
  71          {
  72   1        switch(step)
  73   1        {
  74   2          case 0: //ABÏàÍ¨µç£¬ÆÚ¼äCÏà¸ÐÓ¦µç¶¯ÊÆÓÉ¸ºµ½Õý±ä»¯£¬AÉÏ¹Üµ¼Í¨£¬BÏÂ¹Üµ¼Í¨£¬ÆäÓàMOS¹Ü¹Ø¶Ï
  75   2            PWMA_ENO = 0x00; //¹Ø±ÕËùÓÐPWMÊä³ö£¬ÌØ±ðÊÇÉÏÒ»²½CÏàÉÏ¹Üµ¼Í¨£¬ÐèÏÈ¹Ø¶Ï£¬È»ºó¿ªÆôAÏàÉÏ¹Ü
  76   2            PWM1_L = 0; //AÏàÏÂ¹Ü¹Ø¶Ï
  77   2            PWM3_L = 0; //CÏàÏÂ¹Ü¹Ø¶Ï
  78   2            delay_dead(); //ÑÓ³Ù£¬·ÀÖ¹ACÏàÉÏ¹ÜÍ¬Ê±µ¼Í¨
  79   2            PWMA_ENO = 0x01; //´ò¿ªAÏàÉÏ¹ÜPWM
  80   2            PWM2_L = 1; //BÏàÏÂ¹Üµ¼Í¨
  81   2            ADC_CONTR = 0x80+10; //Ñ¡ÔñADC10£¨¼´P0.2£©²ÉÑù
  82   2            if(B_RUN) CMPCR1 = 0x8c + 0x10; //±È½ÏÆ÷ÏÂ½µÑØÖÐ¶ÏÊ¹ÄÜ
  83   2            else CMPCR1 = 0x8c; //µç»úÆô¶¯Ê±¹Ø±Õ±È½ÏÆ÷ÖÐ¶Ï
  84   2            break;
  85   2          case 1: //ACÏàÍ¨µç£¬ÆÚ¼äBÏà¸ÐÓ¦µç¶¯ÊÆÓÉÕýµ½¸º±ä»¯£¬AÏàÉÏ¹Üµ¼Í¨£¬CÏàÏÂ¹Üµ¼Í¨£¬ÆäÓàMOS¹Ü¹Ø¶Ï
  86   2            PWMA_ENO = 0x01;  //AÏàÉÏ¹Üµ¼Í¨
  87   2            PWM1_L = 0; //AÏàÏÂ¹Ü¹Ø¶Ï
  88   2            PWM2_L = 0; //BÏàÏÂ¹Ü¹Ø¶Ï
  89   2            delay_dead(); //ÑÓ³Ù£¬·ÀÖ¹BCÏàÏÂ¹ÜÍ¬Ê±µ¼Í¨
  90   2            PWM3_L = 1; //CÏàÏÂ¹Üµ¼Í¨
  91   2            ADC_CONTR = 0x80 + 9; //Ñ¡ÔñADC9£¨P0.1£©²ÉÑù
  92   2            if(B_RUN) CMPCR1 = 0x8c + 0x20; //±È½ÏÆ÷ÉÏÉýÑØÖÐ¶ÏÊ¹ÄÜ
  93   2            else CMPCR1 = 0x8c; //µç»úÆô¶¯Ê±¹Ø±Õ±È½ÏÆ÷ÖÐ¶Ï
  94   2            break;
  95   2          case 2: //BCÏàÍ¨µç£¬ÆÚ¼äAÏà¸ÐÓ¦µç¶¯ÊÆÓÉ¸ºµ½Õý±ä»¯£¬BÏàÉÏ¹Üµ¼Í¨£¬CÏàÏÂ¹Üµ¼Í¨£¬ÆäÓàMOS¹Ü¹Ø¶Ï
  96   2            PWMA_ENO = 0x00; //¹Ø±ÕËùÓÐPWMÊä³ö£¬ÌØ±ðÊÇÉÏÒ»²½AÏàÉÏ¹Üµ¼Í¨£¬ÐèÏÈ¹Ø¶Ï£¬È»ºó²ÅÄÜ¿ªÆôBÏàÉÏ¹Ü
  97   2            PWM1_L = 0; //AÏàÏÂ¹Ü¹Ø¶Ï
  98   2            PWM2_L = 0; //BÏàÏÂ¹Ü¹Ø¶Ï
  99   2            delay_dead();
 100   2            PWMA_ENO = 0x04;  //´ò¿ªBÏàÉÏ¹ÜPWM
 101   2            PWM3_L = 1; //CÏàÏÂ¹Üµ¼Í¨
 102   2            ADC_CONTR = 0x80+8;   //Ñ¡ÔñADC8£¨P0.0£©²ÉÑù
 103   2            if(B_RUN) CMPCR1 = 0x8c + 0x10; //±È½ÏÆ÷ÏÂ½µÑØÖÐ¶ÏÊ¹ÄÜ
 104   2            else CMPCR1 = 0x8c; //µç»úÆô¶¯Ê±¹Ø±Õ±È½ÏÆ÷ÖÐ¶Ï
 105   2            break;
 106   2          case 3: //BAÏàÍ¨µç£¬ÆÚ¼äCÏà¸ÐÓ¦µç¶¯ÊÆÓÉÕýµ½¸º±ä»¯£¬BÏàÉÏ¹Üµ¼Í¨£¬AÏàÏÂ¹Üµ¼Í¨£¬ÆäÓàMOS¹Ü¹Ø¶Ï
 107   2            PWMA_ENO = 0x04;  //´ò¿ªBÏàÉÏ¹Ü£¬¹Ø±ÕAºÍCÏàÉÏ¹Ü
 108   2            PWM2_L = 0; //BÏàÏÂ¹Ü¹Ø¶Ï
 109   2            PWM3_L = 0; //CÏàÏÂ¹Ü¹Ø¶Ï
 110   2            delay_dead(); //ËÀÇøÑÓÊ±£¬´í¿ªACÏàÏÂ¹ÜËÀÇø
 111   2            PWM1_L = 1; //AÏàÏÂ¹Üµ¼Í¨
 112   2            ADC_CONTR = 0x80 + 10;  //Ñ¡ÔñADC10£¨P0.2£©²ÉÑù
C51 COMPILER V9.60.0.0   MAIN                                                              01/14/2023 20:51:33 PAGE 3   

 113   2            if(B_RUN) CMPCR1 = 0x8c + 0x20; //±È½ÏÆ÷ÉÏÉýÑØÖÐ¶ÏÊ¹ÄÜ
 114   2            else CMPCR1 = 0x8c; //µç»úÆô¶¯Ê±¹Ø±Õ±È½ÏÆ÷ÖÐ¶Ï
 115   2            break;
 116   2          case 4: //CAÏàÍ¨µç£¬ÆÚ¼äBÏà¸ÐÓ¦µç¶¯ÊÆÓÉ¸ºµ½Õý±ä»¯£¬CÏàÉÏ¹Üµ¼Í¨£¬AÏàÏÂ¹Üµ¼Í¨£¬ÆäÓàMOS¹Ü¹Ø¶Ï
 117   2            PWMA_ENO = 0x00;  //¹Ø±ÕËùÓÐÉÏ¹ÜPWM£¬·ÀÖ¹BCÏàÉÏ¹ÜÍ¬Ê±µ¼Í¨
 118   2            PWM2_L = 0; //BÏàÏÂ¹Ü¹Ø¶Ï
 119   2            PWM3_L = 0; //CÏàÏÂ¹Ü¹Ø¶Ï
 120   2            delay_dead(); //ËÀÇøÑÓÊ±£¬´í¿ªBCÏàÉÏ¹ÜËÀÇø
 121   2            PWMA_ENO = 0x10;  //Ê¹ÄÜCÏàÉÏ¹ÜPWM
 122   2            PWM1_L = 1; //AÏàÏÂ¹Üµ¼Í¨
 123   2            ADC_CONTR = 0x80+9; //ADC9£¨P0.1£©²ÉÑù
 124   2            if(B_RUN) CMPCR1 = 0x8c + 0x10; //±È½ÏÆ÷ÏÂ½µÑØÖÐ¶ÏÊ¹ÄÜ
 125   2            else CMPCR1 = 0x8c; //µç»úÆô¶¯Ê±¹Ø±Õ±È½ÏÆ÷ÖÐ¶Ï
 126   2            break;
 127   2          case 5: //CBÏàÍ¨µç£¬ÆÚ¼äAÏà¸ÐÓ¦µç¶¯ÊÆÓÉÕýµ½¸º±ä»¯£¬CÏàÉÏ¹Üµ¼Í¨£¬BÏàÏÂ¹Üµ¼Í¨£¬ÆäÓàMOS¹Ü¹Ø¶Ï
 128   2            PWMA_ENO = 0x10;  //Ê¹ÄÜCÏàÉÏ¹ÜPWM
 129   2            PWM1_L = 0; //AÏàÏÂ¹Ü¹Ø¶Ï
 130   2            PWM3_L = 0; //CÏàÏÂ¹Ü¹Ø¶Ï
 131   2            delay_dead(); //ËÀÇøÑÓÊ±£¬´í¿ªABÏàÏÂ¹ÜËÀÇø
 132   2            PWM2_L = 1; //BÏàÏÂ¹Üµ¼Í¨
 133   2            ADC_CONTR = 0x80 + 8; //ADC8£¨P0.0£©²ÉÑù
 134   2            if(B_RUN) CMPCR1 = 0x8c + 0x20; //±È½ÏÆ÷ÉÏÉýÑØÖÐ¶ÏÊ¹ÄÜ
 135   2            else CMPCR1 = 0x8c; //µç»úÆô¶¯Ê±¹Ø±Õ±È½ÏÆ÷ÖÐ¶Ï
 136   2            break;
 137   2          default:
 138   2            break;
 139   2        }
 140   1      }
 141          
 142          
 143          
 144          void PWMA_config(void)
 145          {
 146   1        P_SW2 |= 0x80;    //SFR enable   
 147   1        
 148   1      //ÏÈ½«MOS¹ÜÑ¡Í¨ÐÅºÅÀ­µÍ£¬·ÀÖ¹Îóµ¼Í¨
 149   1        PWM1 = 0;
 150   1        PWM1_L = 0;
 151   1        PWM2 = 0;
 152   1        PWM2_L = 0;
 153   1        PWM3 = 0;
 154   1        PWM3_L = 0;
 155   1        
 156   1        //ÅäÖÃÑ¡Í¨Òý½ÅÎªÍÆÍìÊä³ö£¬M0ÏàÓ¦bitÎª1£¬M1ÏàÓ¦bitÎª0
 157   1        P1M0 |= 0x3f; //0x3f = 0B0011 1111£¬bit0~bit5ÖÃ1
 158   1        P1M1 &= ~0x3f; //~0x3f = 0B1100 0000,bit0~bit5ÖÃ0
 159   1        
 160   1        PWMA_PSCR = 3;  //PWMA_PSCRÎªPWMAµÄ16Î»Ô¤·ÖÆµÆ÷¼Ä´æÆ÷£¬¿ÉÒÔ16Î»Êý¾Ý¶ÁÐ´£¬f_ck_int = f_ck_psc/(PSCR[15:0]+1
             -)
 161   1        PWMA_DTR = 24;  //PWMA_DTRÎ»PWMAµÄËÀÇø¼Ä´æÆ÷£¬ÉèÖÃËÀÇø³ÖÐøÊ±¼ä£¬±¾³ÌÐòËÀÇø»¥²¹¹¦ÄÜÎ´¿ª
 162   1        
 163   1        PWMA_ARR = 0xff;  //PWMA_ARRÎªPWMAµÄ16Î»×Ô¶¯ÖØÔØ¼Ä´æÆ÷
 164   1        PWMA_CCER1 = 0; //²¶»ñ/±È½ÏÊ¹ÄÜ¼Ä´æÆ÷1£¬ÅäÖÃ¼«ÐÔ¼°Êä³öÊ¹ÄÜ
 165   1        PWMA_CCER2 = 0; //²¶»ñ/±È½ÏÊ¹ÄÜ¼Ä´æÆ÷2£¬ÅäÖÃ¼«ÐÔ¼°Êä³öÊ¹ÄÜ
 166   1        PWMA_SR1 = 0;   //×´Ì¬¼Ä´æÆ÷1£¬ÖÐ¶Ï±ê¼Ç
 167   1        PWMA_SR2 = 0;   //×´Ì¬¼Ä´æÆ÷2£¬ÖØ¸´²¶»ñ±ê¼Ç
 168   1        PWMA_ENO = 0;   //Êä³öÊ¹ÄÜ¼Ä´æÆ÷
 169   1        PWMA_PS = 0;    //¹¦ÄÜ½ÅÇÐ»»
 170   1        PWMA_IER = 0;   //ÖÐ¶ÏÊ¹ÄÜ¼Ä´æÆ÷
 171   1        
 172   1        PWMA_CCMR1 = 0x68;  //²¶»ñ/±È½ÏÄ£Ê½¼Ä´æÆ÷1£¬0x68 = 0b0110 1000ÅäÖÃÎªÊä³ö£¬¿ªÆôÔ¤×°ÔØ£¬PWMÄ£Ê½1
 173   1        PWMA_CCR1 = 0x00;     //²¶»ñ/±È½Ï¼Ä´æÆ÷£¬16Î»£¬µ±Ç°±È½ÏÖµ
C51 COMPILER V9.60.0.0   MAIN                                                              01/14/2023 20:51:33 PAGE 4   

 174   1        PWMA_CCER1 |= 0x01; //²¶»ñ/±È½ÏÊ¹ÄÜ¼Ä´æÆ÷1£¬Ô­0x05 = 0b0000 0101,ÏÖ¸ÄÎª0x01£¬Ê¹ÄÜOC1Êä³ö
 175   1        PWMA_PS |= 0;       //PWMA IOÑ¡Ôñ
 176   1        
 177   1        PWMA_CCMR2 = 0x68;  //²¶»ñ/±È½ÏÄ£Ê½¼Ä´æÆ÷2£¬0x68 = 0b0110 1000ÅäÖÃÎªÊä³ö£¬¿ªÆôÔ¤×°ÔØ£¬PWMÄ£Ê½1
 178   1        PWMA_CCR2 = 0x00;     //²¶»ñ/±È½Ï¼Ä´æÆ÷£¬16Î»£¬µ±Ç°±È½ÏÖµ£¬ÓëPWMA_ARR±È½Ï
 179   1        PWMA_CCER1 |= 0x10; //²¶»ñ/±È½ÏÊ¹ÄÜ¼Ä´æÆ÷1£¬Ô­0x50 = 0b0101 0000£¬ÏÖ¸ÄÎª0x10£¬Ê¹ÄÜOC2Êä³ö
 180   1        PWMA_PS |= (0<<2);  //PWMA IOÑ¡Ôñ
 181   1        
 182   1        PWMA_CCMR3 = 0x68;  //²¶»ñ/±È½ÏÄ£Ê½¼Ä´æÆ÷3£¬0x68 = 0b0110 1000ÅäÖÃÎªÊä³ö£¬¿ªÆôÔ¤×°ÔØ£¬PWMÄ£Ê½1
 183   1        PWMA_CCR3 = 0x00;     //²¶»ñ/±È½Ï¼Ä´æÆ÷£¬16Î»£¬µ±Ç°±È½ÏÖµ
 184   1        PWMA_CCER2 |= 0x01; //²¶»ñ/±È½ÏÊ¹ÄÜ¼Ä´æÆ÷2£¬Ô­0x05 = 0b0000 0101,ÏÖ¸ÄÎª0x01£¬Ê¹ÄÜOC3Êä³ö
 185   1        PWMA_PS |= (0<<4);  //PWMA IOÑ¡Ôñ
 186   1        
 187   1        PWMA_BKR = 0x80;  //Ê¹ÄÜOCºÍOCNÊä³ö
 188   1        PWMA_CR1 = 0x81;  //¿ØÖÆ¼Ä´æÆ÷1£¬Ê¹ÄÜ×Ô¶¯Ô¤×°ÔØ£¬±ßÑØ¶ÔÆë£¬ÏòÉÏ¼ÆÊý£¬Ê¹ÄÜ¼ÆÊýÆ÷
 189   1        PWMA_EGR = 0x01;  //³õÊ¼»¯¼ÆÊýÆ÷
 190   1      }
 191          
 192          //  PWMA_PS   = (0<<6)+(0<<4)+(0<<2)+0; //Ñ¡ÔñIO, 4Ïî´Ó¸ßµ½µÍ(´Ó×óµ½ÓÒ)¶ÔÓ¦PWM1 PWM2 PWM3 PWM4, 0:Ñ¡ÔñP1.x,
             - 1:Ñ¡ÔñP2.x, 2:Ñ¡ÔñP6.x, 
 193          //  PWMA_PS    PWM4N PWM4P    PWM3N PWM3P    PWM2N PWM2P    PWM1N PWM1P
 194          //    00       P1.7  P1.6     P1.5  P1.4     P1.3  P1.2     P1.1  P1.0
 195          //    01       P2.7  P2.6     P2.5  P2.4     P2.3  P2.2     P2.1  P2.0
 196          //    02       P6.7  P6.6     P6.5  P6.4     P6.3  P6.2     P6.1  P6.0
 197          //    03       P3.3  P3.4      --    --       --    --       --    --
 198          
 199          
 200          void ADC_config(void) //ADC³õÊ¼»¯º¯Êý(ÎªÁËÊ¹ÓÃADCÊäÈë¶Ë×ö±È½ÏÆ÷ÐÅºÅ, Êµ¼ÊÃ»ÓÐÆô¶¯ADC×ª»»)
 201          {
 202   1        P1n_pure_input(0xc0); //ÉèÖÃÎª¸ß×èÊäÈë
 203   1        P0n_pure_input(0x0f); //ÉèÖÃÎª¸ß×èÊäÈë
 204   1        ADC_CONTR = 0x80 + 6; //ADC on + channel
 205   1        ADCCFG = RES_FMT + ADC_SPEED;
 206   1        P_SW2 |=  0x80; //·ÃÎÊXSFR
 207   1        ADCTIM = CSSETUP + CSHOLD + SMPDUTY;
 208   1      }
 209          
 210          void CMP_config(void) //±È½ÏÆ÷³õÊ¼»¯³ÌÐò
 211          {
 212   1        CMPCR1 = 0x8C;      // 1000 1100 ´ò¿ª±È½ÏÆ÷£¬P3.6×÷Îª±È½ÏÆ÷µÄ·´ÏàÊäÈë¶Ë£¬ADCÒý½Å×÷ÎªÕýÊäÈë¶Ë 
 213   1        CMPCR2 = 60;      //60¸öÊ±ÖÓÂË²¨   ±È½Ï½á¹û±ä»¯ÑÓÊ±ÖÜÆÚÊý, 0~63
 214   1        P3n_pure_input(0x40); //CMP-(P3.6)ÉèÖÃÎª¸ß×è.
 215   1        
 216   1        P_SW2 |= 0x80;    //SFR enable   
 217   1      //  CMPEXCFG |= (0<<6); //bit7 bit6: ±È½ÏÆ÷³ÙÖÍÊäÈëÑ¡Ôñ: 0: 0mV,  1: 10mV, 2: 20mV, 3: 30mV
 218   1      //  CMPEXCFG |= (0<<2); //bit2: ÊäÈë¸º¼«ÐÔÑ¡Ôñ, 0: Ñ¡ÔñP3.6×öÊäÈë,   1: Ñ¡ÔñÄÚ²¿BandGapµçÑ¹BGv×ö¸ºÊäÈë.
 219   1      //  CMPEXCFG |=  0;   //bit1 bit0: ÊäÈëÕý¼«ÐÔÑ¡Ôñ, 0: Ñ¡ÔñP3.7×öÊäÈë,   1: Ñ¡ÔñP5.0×öÊäÈë,  2: Ñ¡ÔñP5.1×öÊäÈ
             -ë,  3: Ñ¡ÔñADCÊäÈë(ÓÉADC_CHS[3:0]ËùÑ¡ÔñµÄADCÊäÈë¶Ë×öÕýÊäÈë).
 220   1      //  CMPEXCFG = (0<<6)+(0<<2)+3;
 221   1      }
 222          
 223          void CMP_ISR(void) interrupt 21   //±È½ÏÆ÷ÖÐ¶Ïº¯Êý, ¼ì²âµ½·´µç¶¯ÊÆ¹ý0ÊÂ¼þ
 224          {
 225   1        u8  i;
 226   1        CMPCR1 &= ~0x40;  // ÐèÈí¼þÇå³ýÖÐ¶Ï±êÖ¾Î»
 227   1      
 228   1        if(XiaoCiCnt == 0)  //Ïû´Åºó²Å¼ì²â¹ý0ÊÂ¼þ,   XiaoCiCnt=1:ÐèÒªÏû´Å, =2:ÕýÔÚÏû´Å, =0ÒÑ¾­Ïû´Å
 229   1        {
 230   2          T4T3M &= ~(1<<3); // Timer3Í£Ö¹ÔËÐÐ
 231   2          if(B_Timer3_OverFlow) //ÇÐ»»Ê±¼ä¼ä¸ô(Timer3)ÓÐÒç³ö
 232   2          {
 233   3            B_Timer3_OverFlow = 0;
C51 COMPILER V9.60.0.0   MAIN                                                              01/14/2023 20:51:33 PAGE 5   

 234   3            PhaseTime = 8000; //»»ÏàÊ±¼ä×î´ó8ms, 2212µç»ú12V¿Õ×ª×î¸ßËÙ130usÇÐ»»Ò»Ïà(200RPS 12000RPM), 480mA
 235   3          }
 236   2          else
 237   2          {
 238   3            PhaseTime = (((u16)T3H << 8) + T3L) >> 1; //µ¥Î»Îª1us
 239   3            if(PhaseTime >= 8000) PhaseTime = 8000; //»»ÏàÊ±¼ä×î´ó8ms, 2212µç»ú12V¿Õ×ª×î¸ßËÙ130usÇÐ»»Ò»Ïà(200RPS 12
             -000RPM), 480mA
 240   3          }
 241   2          T3H = 0;  T3L = 0;
 242   2          T4T3M |=  (1<<3); //Timer3¿ªÊ¼ÔËÐÐ
 243   2      
 244   2          PhaseTimeTmp[TimeIndex] = PhaseTime;  //±£´æÒ»´Î»»ÏàÊ±¼ä
 245   2          if(++TimeIndex >= 8)  TimeIndex = 0;  //ÀÛ¼Ó8´Î
 246   2          for(PhaseTime=0, i=0; i<8; i++) PhaseTime += PhaseTimeTmp[i]; //Çó8´Î»»ÏàÊ±¼äÀÛ¼ÓºÍ
 247   2          PhaseTime = PhaseTime >> 4;   //Çó8´Î»»ÏàÊ±¼äµÄÆ½¾ùÖµµÄÒ»°ë, ¼´30¶Èµç½Ç¶È
 248   2          if((PhaseTime >= 40) && (PhaseTime <= 1000))  TimeOut = 125;  //¶Â×ª500ms³¬Ê±
 249   2          if( PhaseTime >= 60)  PhaseTime -= 40;  //ÐÞÕýÓÉÓÚÂË²¨µçÈÝÒýÆðµÄÖÍºóÊ±¼ä
 250   2          else          PhaseTime  = 20;
 251   2          
 252   2        //  PhaseTime = 20; //Ö»¸ø20us, ÔòÎÞÖÍºóÐÞÕý, ÓÃÓÚ¼ì²âÂË²¨µçÈÝÒýÆðµÄÖÍºóÊ±¼ä
 253   2          T4T3M &= ~(1<<7);       //Timer4Í£Ö¹ÔËÐÐ
 254   2          PhaseTime  = PhaseTime  << 1; //2¸ö¼ÆÊý1us
 255   2          PhaseTime = 0 - PhaseTime;
 256   2          T4H = (u8)(PhaseTime >> 8);   //×°ÔØ30¶È½ÇÑÓÊ±
 257   2          T4L = (u8)PhaseTime;
 258   2          T4T3M |=  (1<<7); //Timer4¿ªÊ¼ÔËÐÐ
 259   2          XiaoCiCnt = 1;    //1:ÐèÒªÏû´Å, 2:ÕýÔÚÏû´Å, 0ÒÑ¾­Ïû´Å
 260   2        }
 261   1      }
 262          
 263          void Timer0_config(void)  //Timer0³õÊ¼»¯º¯Êý
 264          {
 265   1        Timer0_16bitAutoReload(); // T0¹¤×÷ÓÚ16Î»×Ô¶¯ÖØ×°
 266   1        Timer0_12T();
 267   1        TH0 = (65536UL-MAIN_Fosc/12 / 250) / 256; //4ms
 268   1        TL0 = (65536UL-MAIN_Fosc/12 / 250) % 256;
 269   1        TR0 = 1; // ´ò¿ª¶¨Ê±Æ÷0
 270   1      
 271   1        ET0 = 1;// ÔÊÐíET0ÖÐ¶Ï
 272   1      }
 273          
 274          void Timer0_ISR(void) interrupt 1 //Timer0ÖÐ¶Ïº¯Êý, 20us
 275          {
 276   1        B_4ms = 1;  //4ms¶¨Ê±±êÖ¾
 277   1      }
 278          
 279          //============================ timer3³õÊ¼»¯º¯Êý ============================================
 280          void  Timer3_Config(void)
 281          {
 282   1        P_SW2 |= 0x80;    //SFR enable   
 283   1        T4T3M &= 0xf0;    //Í£Ö¹¼ÆÊý, ¶¨Ê±Ä£Ê½, 12TÄ£Ê½, ²»Êä³öÊ±ÖÓ
 284   1        T3H = 0;
 285   1        T3L = 0;
 286   1      
 287   1        T3T4PIN = 0x01;   //Ñ¡ÔñIO, 0x00: T3--P0.4, T3CLKO--P0.5, T4--P0.6, T4CLKO--P0.7;    0x01: T3--P0.0, T3CLK
             -O--P0.1, T4--P0.2, T4CLKO--P0.3;
 288   1        IE2   |=  (1<<5); //ÔÊÐíÖÐ¶Ï
 289   1        T4T3M |=  (1<<3); //¿ªÊ¼ÔËÐÐ
 290   1      }
 291          
 292          //============================ timer4³õÊ¼»¯º¯Êý ============================================
 293          void  Timer4_Config(void)
C51 COMPILER V9.60.0.0   MAIN                                                              01/14/2023 20:51:33 PAGE 6   

 294          {
 295   1        P_SW2 |= 0x80;    //SFR enable   
 296   1        T4T3M &= 0x0f;    //Í£Ö¹¼ÆÊý, ¶¨Ê±Ä£Ê½, 12TÄ£Ê½, ²»Êä³öÊ±ÖÓ
 297   1        T4H = 0;
 298   1        T4L = 0;
 299   1      
 300   1        T3T4PIN = 0x01;   //Ñ¡ÔñIO, 0x00: T3--P0.4, T3CLKO--P0.5, T4--P0.6, T4CLKO--P0.7;    0x01: T3--P0.0, T3CLK
             -O--P0.1, T4--P0.2, T4CLKO--P0.3;
 301   1        IE2   |=  (1<<6); //ÔÊÐíÖÐ¶Ï
 302   1      //  T4T3M |=  (1<<7); //¿ªÊ¼ÔËÐÐ
 303   1      }
 304          
 305          //=========================== timer3ÖÐ¶Ïº¯Êý =============================================
 306          void timer3_ISR (void) interrupt TIMER3_VECTOR
 307          {
 308   1        B_Timer3_OverFlow = 1;  //Òç³ö±êÖ¾
 309   1      }
 310          
 311          //=========================== timer4ÖÐ¶Ïº¯Êý =============================================
 312          void timer4_ISR (void) interrupt TIMER4_VECTOR
 313          {
 314   1        T4T3M &= ~(1<<7); //Timer4Í£Ö¹ÔËÐÐ
 315   1        if(XiaoCiCnt == 1)    //±ê¼ÇÐèÒªÏû´Å. Ã¿´Î¼ì²âµ½¹ý0ÊÂ¼þºóµÚÒ»´ÎÖÐ¶ÏÎª30¶È½ÇÑÓÊ±, ÉèÖÃÏû´ÅÑÓÊ±.
 316   1        {
 317   2          XiaoCiCnt = 2;    //1:ÐèÒªÏû´Å, 2:ÕýÔÚÏû´Å, 0ÒÑ¾­Ïû´Å
 318   2          if(B_RUN) //µç»úÕýÔÚÔËÐÐ
 319   2          {
 320   3            if(++step >= 6) step = 0;
 321   3            StepMotor();
 322   3          }
 323   2                          //Ïû´ÅÊ±¼ä, »»ÏàºóÏßÈ¦(µç¸Ð)µçÁ÷¼õÐ¡µ½0µÄ¹ý³ÌÖÐ, ³öÏÖ·´µç¶¯ÊÆ, µçÁ÷Ô½´óÏû´ÅÊ±¼äÔ½³¤, ¹ý0¼ì²âÒªÔÚ
             -Õâ¸öÊ±¼äÖ®ºó
 324   2                          //100%Õ¼¿Õ±ÈÊ±Ê©¼Ó½ÏÖØ¸ºÔØ, µç»úµçÁ÷ÉÏÉý, ¿ÉÒÔÊ¾²¨Æ÷¿´Ïû´ÅÊ±¼ä.
 325   2                          //Êµ¼ÊÉÏ, Ö»ÒªÔÚ»»ÏàºóÑÓÊ±¼¸Ê®us²Å¼ì²â¹ýÁã, ¾Í¿ÉÒÔÁË
 326   2          T4H = (u8)((65536UL - 40*2) >> 8);  //×°ÔØÏû´ÅÑÓÊ±
 327   2          T4L = (u8)(65536UL - 40*2);
 328   2          T4T3M |=  (1<<7); //Timer4¿ªÊ¼ÔËÐÐ
 329   2        }
 330   1        else if(XiaoCiCnt == 2) XiaoCiCnt = 0;    //1:ÐèÒªÏû´Å, 2:ÕýÔÚÏû´Å, 0ÒÑ¾­Ïû´Å
 331   1      }
 332          
 333          
 334          #define D_START_PWM   30
 335          /******************* Ç¿ÖÆµç»úÆô¶¯º¯Êý ***************************/
 336          void StartMotor(void)
 337          {
 338   1        u16 timer,i;
 339   1        CMPCR1 = 0x8C;  // ¹Ø±È½ÏÆ÷ÖÐ¶Ï
 340   1      
 341   1        PWM_Value  = D_START_PWM; // ³õÊ¼Õ¼¿Õ±È, ¸ù¾Ýµç»úÌØÐÔÉèÖÃ
 342   1        PWMA_CCR1L = PWM_Value;
 343   1        PWMA_CCR2L = PWM_Value;
 344   1        PWMA_CCR3L = PWM_Value;
 345   1        step = 0; StepMotor();  Delay_n_ms(50); //Delay_n_ms(250);// ³õÊ¼Î»ÖÃ
 346   1        timer = 200;  //·çÉÈµç»úÆô¶¯
 347   1      
 348   1        while(1)
 349   1        {
 350   2          for(i=0; i<timer; i++)  delay_us(100);  //¸ù¾Ýµç»ú¼ÓËÙÌØÐÔ, ×î¸ß×ªËÙµÈµÈµ÷ÕûÆô¶¯¼ÓËÙËÙ¶È
 351   2          timer -= timer /16;
 352   2          if(++step >= 6) step = 0;
 353   2          StepMotor();
C51 COMPILER V9.60.0.0   MAIN                                                              01/14/2023 20:51:33 PAGE 7   

 354   2          if(timer < 40)  return;
 355   2        }
 356   1      }
 357          
 358          /**********************************************/
 359          void main(void)
 360          {
 361   1        u8  i;
 362   1        
 363   1        P2n_standard(0xf8);
 364   1        P3n_standard(0xbf);
 365   1        P5n_standard(0x10);
 366   1        
 367   1        PWMA_config();
 368   1        ADC_config();
 369   1        CMP_config();
 370   1        Timer0_config();  // Timer0³õÊ¼»¯º¯Êý
 371   1        Timer3_Config();  // Timer3³õÊ¼»¯º¯Êý
 372   1        Timer4_Config();  // Timer4³õÊ¼»¯º¯Êý
 373   1        PWW_Set = 0;
 374   1        TimeOut = 0;
 375   1      
 376   1        EA  = 1; // ´ò¿ª×ÜÖÐ¶Ï
 377   1      
 378   1        while (1)
 379   1        {
 380   2          if(B_4ms)   // 4msÊ±Ï¶
 381   2          {
 382   3            B_4ms = 0;
 383   3      
 384   3            if(TimeOut != 0)
 385   3            {
 386   4              if(--TimeOut == 0)  //¶Â×ª³¬Ê±
 387   4              {
 388   5                B_RUN  = 0;
 389   5                PWM_Value = 0;
 390   5                CMPCR1 = 0x8C;  // ¹Ø±È½ÏÆ÷ÖÐ¶Ï
 391   5                PWMA_ENO  = 0;
 392   5                PWMA_CCR1L = 0; PWMA_CCR2L = 0; PWMA_CCR3L = 0;
 393   5                PWM1_L=0; PWM2_L=0; PWM3_L=0;
 394   5                Delay_n_ms(250);  //¶Â×ªÊ±,ÑÓÊ±Ò»µãÊ±¼äÔÙÆô¶¯
 395   5              }
 396   4            }
 397   3      
 398   3            if(!B_RUN && (PWW_Set >= D_START_PWM))  // Õ¼¿Õ±È´óÓÚÉè¶¨Öµ, ²¢ÇÒµç»úÎ´ÔËÐÐ, ÔòÆô¶¯µç»ú
 399   3            {
 400   4              B_start = 1;    //Æô¶¯Ä£Ê½
 401   4              for(i=0; i<8; i++)  PhaseTimeTmp[i] = 400;
 402   4              StartMotor();   // Æô¶¯µç»ú
 403   4              B_start = 0;
 404   4              XiaoCiCnt = 0;    //³õÊ¼½øÈëÊ±
 405   4              CMPCR1 &= ~0x40;  // Çå³ýÖÐ¶Ï±êÖ¾Î»
 406   4              if(step & 1)  CMPCR1 = 0xAC;    //ÉÏÉýÑØÖÐ¶Ï
 407   4              else      CMPCR1 = 0x9C;    //ÏÂ½µÑØÖÐ¶Ï
 408   4              B_RUN = 1;
 409   4              Delay_n_ms(250);  //ÑÓÊ±Ò»ÏÂ, ÏÈÆô¶¯ÆðÀ´
 410   4              Delay_n_ms(250);
 411   4              TimeOut = 125;    //Æô¶¯³¬Ê±Ê±¼ä 125*4 = 500ms
 412   4            }
 413   3      
 414   3            if(B_RUN) //ÕýÔÚÔËÐÐÖÐ
 415   3            {
C51 COMPILER V9.60.0.0   MAIN                                                              01/14/2023 20:51:33 PAGE 8   

 416   4              if(PWM_Value < PWW_Set) PWM_Value++;  //ÓÍÃÅ¸úËæµçÎ»Æ÷
 417   4              if(PWM_Value > PWW_Set) PWM_Value--;
 418   4              if(PWM_Value < (D_START_PWM-10))  // Í£×ª, Í£×ªÕ¼¿Õ±È ±È Æô¶¯Õ¼¿Õ±È Ð¡10/256
 419   4              {
 420   5                B_RUN = 0;
 421   5                PWM_Value = 0;
 422   5                CMPCR1 = 0x8C;  // ¹Ø±È½ÏÆ÷ÖÐ¶Ï
 423   5                PWMA_ENO  = 0;
 424   5                PWMA_CCR1L = 0; PWMA_CCR2L = 0; PWMA_CCR3L = 0;
 425   5                PWM1_L=0; PWM2_L=0; PWM3_L=0;
 426   5              }
 427   4              else
 428   4              {
 429   5                PWMA_CCR1L = PWM_Value;
 430   5                PWMA_CCR2L = PWM_Value;
 431   5                PWMA_CCR3L = PWM_Value;
 432   5              }
 433   4            }
 434   3            else
 435   3            {
 436   4              //adc11 = ((adc11 *7)>>3) + Get_ADC10bitResult(11);
 437   4            } 
 438   3            PWW_Set = 100;
 439   3          }
 440   2        }
 441   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1230    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     24    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
